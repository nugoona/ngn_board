<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>STEP 2 - ADMAKE</title>
  <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='img/favicon.ico') }}">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <!-- Fonts: Inter Tight (영문/숫자) + Pretendard (한글) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter+Tight:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" rel="stylesheet">

  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}?v=1.4">

  <style>
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #111111;
      --bg-card: #161616;
      --bg-card-hover: #1a1a1a;
      --bg-input: #0d0d0d;
      --border-subtle: rgba(255, 255, 255, 0.06);
      --border-hover: rgba(255, 255, 255, 0.12);
      --border-focus: rgba(255, 255, 255, 0.2);
      --text-primary: #ffffff;
      --text-secondary: #a1a1a1;
      --text-muted: #525252;
      --accent-blue: #3b82f6;
      --accent-emerald: #10b981;
      --accent-gold: #f59e0b;
      --accent-red: #ef4444;
      /* 비율별 컬러 */
      --ratio-916: #3b82f6;    /* 딥블루 */
      --ratio-45: #10b981;     /* 에메랄드 */
      --ratio-11: #f59e0b;     /* 소프트 골드 */
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg-primary);
      font-family: 'Pretendard', 'Inter Tight', -apple-system, BlinkMacSystemFont, sans-serif;
      height: 100vh;
      overflow: hidden; /* 페이지 스크롤 방지 */
      color: var(--text-primary);
    }

    .font-inter {
      font-family: 'Inter Tight', sans-serif;
    }

    /* ===== 네비게이션 오버라이드 ===== */
    .nav-buttons {
      background: var(--bg-primary) !important;
      border-bottom: 1px solid var(--border-subtle) !important;
      height: 56px;
      flex-shrink: 0;
    }

    .nav-buttons .updated-at-text {
      color: var(--text-primary) !important;
      font-family: 'Inter Tight', sans-serif !important;
      font-weight: 700 !important;
      letter-spacing: 0.1em !important;
    }

    .hamburger-icon div {
      background: var(--text-primary) !important;
    }

    .hamburger-dropdown {
      background: var(--bg-secondary) !important;
      border: 1px solid var(--border-subtle) !important;
    }

    .hamburger-dropdown a {
      color: var(--text-secondary) !important;
    }

    .hamburger-dropdown a:hover {
      background: var(--bg-card) !important;
      color: var(--text-primary) !important;
    }

    /* ===== Progress Bar - Step 1과 동일 ===== */
    .admake-progress-bar {
      position: sticky;
      top: 56px;
      z-index: 100;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(17, 17, 17, 0.95) 100%);
      border-bottom: 1px solid var(--border-subtle);
      padding: 20px 40px 18px;
      backdrop-filter: blur(12px);
      flex-shrink: 0;
    }

    .admake-progress-steps {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 6px;
      max-width: 900px;
      margin: 0 auto;
    }

    .admake-progress-step {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      padding: 10px 20px;
      border-radius: 8px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid transparent;
    }

    .admake-progress-step .step-number {
      font-family: 'Inter Tight', sans-serif;
      font-size: 13px;
      font-weight: 700;
      color: var(--text-muted);
      letter-spacing: 0.02em;
    }

    .admake-progress-step .step-label {
      font-family: 'Pretendard', sans-serif;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      white-space: nowrap;
      opacity: 0.7;
    }

    .admake-progress-step.active {
      background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1), 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .admake-progress-step.active .step-number {
      font-size: 14px;
      color: #1a1a1a;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.8), 0 -1px 1px rgba(0, 0, 0, 0.15);
    }

    .admake-progress-step.active .step-label {
      font-size: 13px;
      font-weight: 600;
      color: #2a2a2a;
      opacity: 1;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.7), 0 -1px 1px rgba(0, 0, 0, 0.1);
    }

    .admake-progress-step.completed {
      background: rgba(16, 185, 129, 0.08);
      border-color: rgba(16, 185, 129, 0.15);
    }

    .admake-progress-step.completed .step-number,
    .admake-progress-step.completed .step-label {
      color: var(--accent-emerald);
      opacity: 1;
    }

    .admake-progress-connector {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 4px;
    }

    .admake-progress-connector::before,
    .admake-progress-connector::after {
      content: '';
      width: 12px;
      height: 1px;
      background: var(--border-subtle);
    }

    .admake-progress-connector-dot {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: var(--text-muted);
      opacity: 0.4;
    }

    .admake-progress-connector.completed::before,
    .admake-progress-connector.completed::after {
      background: var(--accent-emerald);
    }

    .admake-progress-connector.completed .admake-progress-connector-dot {
      background: var(--accent-emerald);
      opacity: 1;
    }

    /* ===== 메인 레이아웃 - 뷰포트 고정 ===== */
    .admake-crop-wrapper {
      display: flex;
      padding-top: 40px; /* 프로그레스바와 겹침 방지 */
      height: calc(100vh - 56px - 105px - 72px); /* nav + progress + action bar */
      overflow: hidden;
      box-sizing: border-box;
    }

    /* ===== 좌측: 미디어 리스트 ===== */
    .admake-crop-left {
      width: 200px;
      flex-shrink: 0;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-subtle);
      display: flex;
      flex-direction: column;
    }

    .admake-media-list {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: 16px;
    }

    .admake-media-list-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      flex-shrink: 0;
    }

    .admake-media-list-number {
      font-family: 'Inter Tight', sans-serif;
      font-size: 10px;
      font-weight: 800;
      color: var(--accent-blue);
      background: rgba(59, 130, 246, 0.08);
      border: 1px solid rgba(59, 130, 246, 0.15);
      padding: 4px 8px;
      border-radius: 4px;
      letter-spacing: 0.1em;
    }

    .admake-media-list-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .admake-media-list-container {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 4px;
    }

    /* 스크롤바 스타일링 */
    .admake-media-list-container::-webkit-scrollbar {
      width: 4px;
    }

    .admake-media-list-container::-webkit-scrollbar-track {
      background: var(--bg-card);
      border-radius: 2px;
    }

    .admake-media-list-container::-webkit-scrollbar-thumb {
      background: var(--text-muted);
      border-radius: 2px;
    }

    .admake-media-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 6px;
      overflow: hidden;
      background: var(--bg-card);
      border: 2px solid var(--border-subtle);
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 10px;
    }

    .admake-media-item:hover {
      border-color: var(--border-hover);
    }

    .admake-media-item.selected {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 1px var(--accent-blue);
    }

    .admake-media-item-image,
    .admake-media-item-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .admake-media-item-badge {
      position: absolute;
      top: 4px;
      left: 4px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Inter Tight', sans-serif;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .admake-media-item-checked {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: var(--bg-primary);
      color: #fff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .admake-media-item.selected .admake-media-item-checked {
      opacity: 1;
      background: var(--accent-blue);
    }

    .admake-media-item-checked.confirmed {
      opacity: 1;
      background: var(--accent-emerald);
    }

    /* ===== 중앙: 크롭 캔버스 ===== */
    .admake-crop-center {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      position: relative;
      background: var(--bg-primary);
    }

    .admake-canvas-wrapper {
      position: relative;
      display: flex;
      align-items: flex-start;
    }

    /* 비율 버튼 - 그리드 좌측에 밀착 */
    .admake-ratio-buttons-vertical {
      position: absolute;
      left: -50px;
      top: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      z-index: 20;
    }

    .admake-ratio-btn-v {
      width: 44px;
      padding: 8px 4px;
      font-family: 'Inter Tight', sans-serif;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.02em;
      border: none;
      background: var(--bg-card);
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      border-left: 3px solid transparent;
    }

    .admake-ratio-btn-v:first-child {
      border-radius: 6px 0 0 0;
    }

    .admake-ratio-btn-v:last-child {
      border-radius: 0 0 0 6px;
    }

    .admake-ratio-btn-v:hover {
      background: var(--bg-card-hover);
      color: var(--text-secondary);
    }

    .admake-ratio-btn-v.active-916 {
      background: rgba(59, 130, 246, 0.15);
      color: var(--ratio-916);
      border-left-color: var(--ratio-916);
    }

    .admake-ratio-btn-v.active-45 {
      background: rgba(16, 185, 129, 0.15);
      color: var(--ratio-45);
      border-left-color: var(--ratio-45);
    }

    .admake-ratio-btn-v.active-11 {
      background: rgba(245, 158, 11, 0.15);
      color: var(--ratio-11);
      border-left-color: var(--ratio-11);
    }

    /* 크롭 컨테이너 - Sharp Edge */
    .admake-guide-container {
      position: relative;
      width: 320px;
      aspect-ratio: 9 / 16;
      background: #000;
      border: none;
      border-radius: 0; /* Sharp Edge */
      overflow: hidden;
      cursor: move;
      user-select: none;
      box-shadow: none; /* 그림자 제거 */
    }

    .admake-guide-preview {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    .admake-crop-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: move;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* 가이드 라인 - 비율별 컬러 */
    .admake-guide-line {
      position: absolute;
      pointer-events: none;
      z-index: 12;
      box-sizing: border-box;
    }

    .admake-guide-line-4-5 {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 70.31%;
      border: 2px solid var(--ratio-45);
    }

    .admake-guide-line-1-1 {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 56.25%;
      border: 2px solid var(--ratio-11);
    }

    .admake-guide-line-4-5.hidden,
    .admake-guide-line-1-1.hidden {
      display: none;
    }

    /* 9:16 외곽선 (선택 시) */
    .admake-guide-container.ratio-916 {
      outline: 2px solid var(--ratio-916);
      outline-offset: -2px;
    }

    .admake-guide-container.ratio-45 .admake-guide-line-4-5 {
      border-width: 3px;
      box-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
    }

    .admake-guide-container.ratio-11 .admake-guide-line-1-1 {
      border-width: 3px;
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.3);
    }

    .admake-video-notice {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      z-index: 20;
      backdrop-filter: blur(8px);
    }

    /* ===== 우측: 컨트롤 패널 ===== */
    .admake-crop-right {
      width: 280px;
      flex-shrink: 0;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-subtle);
      display: flex;
      flex-direction: column;
      padding: 24px 20px;
      overflow-y: auto;
    }

    .admake-control-section {
      margin-bottom: 28px;
    }

    .admake-control-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 14px;
    }

    .admake-control-number {
      font-family: 'Inter Tight', sans-serif;
      font-size: 10px;
      font-weight: 800;
      color: var(--accent-blue);
      background: rgba(59, 130, 246, 0.08);
      border: 1px solid rgba(59, 130, 246, 0.15);
      padding: 3px 7px;
      border-radius: 4px;
      letter-spacing: 0.1em;
    }

    .admake-control-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }

    /* 비율 버튼 그룹 */
    .admake-ratio-buttons {
      display: flex;
      gap: 8px;
    }

    .admake-ratio-btn {
      flex: 1;
      padding: 12px 8px;
      font-family: 'Inter Tight', sans-serif;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.02em;
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    .admake-ratio-btn:hover {
      background: var(--bg-card-hover);
      border-color: var(--border-hover);
    }

    .admake-ratio-btn.active {
      background: var(--text-primary);
      color: var(--bg-primary);
      border-color: var(--text-primary);
    }

    /* 줌 컨트롤 */
    .admake-zoom-control {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .admake-zoom-slider {
      flex: 1;
      height: 4px;
      background: var(--bg-card);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .admake-zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--text-primary);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .admake-zoom-value {
      font-family: 'Inter Tight', sans-serif;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 48px;
      text-align: right;
    }

    /* 해상도 표시 */
    .admake-resolution-display {
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: 8px;
      padding: 14px;
      text-align: center;
    }

    .admake-resolution-label {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .admake-resolution-value {
      font-family: 'Inter Tight', sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }

    .admake-resolution-status {
      font-size: 11px;
      margin-top: 6px;
      color: var(--accent-emerald);
    }

    .admake-resolution-status.warning {
      color: var(--accent-red);
    }

    /* 확인 버튼 */
    .admake-confirm-btn {
      width: 100%;
      padding: 14px;
      font-family: 'Pretendard', sans-serif;
      font-size: 14px;
      font-weight: 600;
      background: var(--text-primary);
      color: var(--bg-primary);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      margin-top: auto;
    }

    .admake-confirm-btn:hover:not(:disabled) {
      background: #e5e5e5;
    }

    .admake-confirm-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .admake-confirm-btn.confirmed {
      background: var(--accent-emerald);
      color: #fff;
    }

    /* ===== 하단 액션 바 ===== */
    .admake-action-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 72px;
      background: linear-gradient(180deg, rgba(17, 17, 17, 0.95) 0%, var(--bg-secondary) 100%);
      border-top: 1px solid var(--border-subtle);
      padding: 0 40px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(12px);
    }

    .admake-action-left {
      font-family: 'Inter Tight', sans-serif;
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.06em;
      font-weight: 500;
    }

    .admake-action-buttons {
      display: flex;
      gap: 10px;
    }

    .admake-btn {
      font-family: 'Inter Tight', sans-serif;
      padding: 12px 28px;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.08em;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.25s;
      text-transform: uppercase;
    }

    .admake-btn-secondary {
      background: var(--bg-card);
      color: var(--text-secondary);
      border: 1px solid var(--border-subtle);
    }

    .admake-btn-secondary:hover {
      background: var(--bg-card-hover);
      border-color: var(--border-hover);
      color: var(--text-primary);
    }

    .admake-btn-primary {
      background: var(--text-primary);
      color: var(--bg-primary);
      box-shadow: 0 2px 8px rgba(255, 255, 255, 0.1);
    }

    .admake-btn-primary:hover:not(:disabled) {
      background: #f0f0f0;
      box-shadow: 0 4px 16px rgba(255, 255, 255, 0.15);
    }

    .admake-btn-primary:disabled {
      opacity: 0.25;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* ===== 로딩 오버레이 ===== */
    .admake-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(8px);
    }

    .admake-loading-overlay.active {
      display: flex;
    }

    .admake-loading-content {
      background: var(--bg-secondary);
      padding: 40px;
      border-radius: 16px;
      text-align: center;
      border: 1px solid var(--border-subtle);
    }

    .admake-loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--bg-card);
      border-top: 3px solid var(--text-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .admake-loading-text {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
    }

    /* 숨김 클래스 */
    .hidden {
      display: none !important;
    }

    /* 가이드 라벨 - 제거됨 (비율 버튼으로 대체) */
    .admake-guide-labels-container,
    .admake-guide-labels-wrapper {
      display: none;
    }
  </style>
</head>
<body>

<script>
  var userCompanyList = {{ session['company_names'] | tojson }};
  var currentUserId = "{{ session['user_id'] }}";
  var accountId = "{{ account_id }}";
</script>
<script src="{{ url_for('static', filename='js/mobile_detection.js') }}"></script>

<!-- 네비게이션 -->
<div class="nav-buttons">
  <div class="nav-left">
    <div id="updatedAtText" class="updated-at-text">ADMAKE</div>
  </div>
  <div class="nav-right">
    <div class="hamburger-menu-wrapper">
      <div class="hamburger-icon" id="hamburgerIcon">
        <div></div><div></div><div></div>
      </div>
      <div class="hamburger-dropdown" id="hamburgerDropdown">
        <a href="/">사이트 성과</a>
        <a href="{{ url_for('ads_page') }}">광고 성과</a>
        <a href="{{ url_for('trend_selection_page') }}">TREND</a>
        <a href="{{ url_for('auth.logout') }}">로그아웃</a>
      </div>
    </div>
  </div>
</div>

<!-- Progress Bar - Step 1과 동일한 스타일 -->
<div class="admake-progress-bar">
  <div class="admake-progress-steps">
    <div class="admake-progress-step completed">
      <span class="step-number font-inter">STEP 1</span>
      <span class="step-label">Media 업로드</span>
    </div>
    <div class="admake-progress-connector completed">
      <span class="admake-progress-connector-dot"></span>
    </div>
    <div class="admake-progress-step active">
      <span class="step-number font-inter">STEP 2</span>
      <span class="step-label">정밀 크롭</span>
    </div>
    <div class="admake-progress-connector">
      <span class="admake-progress-connector-dot"></span>
    </div>
    <div class="admake-progress-step">
      <span class="step-number font-inter">STEP 3</span>
      <span class="step-label">AD 생성</span>
    </div>
    <div class="admake-progress-connector">
      <span class="admake-progress-connector-dot"></span>
    </div>
    <div class="admake-progress-step">
      <span class="step-number font-inter">STEP 4</span>
      <span class="step-label">전략 SETTING</span>
    </div>
    <div class="admake-progress-connector">
      <span class="admake-progress-connector-dot"></span>
    </div>
    <div class="admake-progress-step">
      <span class="step-number font-inter">STEP 5</span>
      <span class="step-label">검토 및 Publish</span>
    </div>
  </div>
</div>

<!-- 메인 컨텐츠 - 3열 레이아웃 -->
<div class="admake-crop-wrapper">

  <!-- 좌측: 미디어 리스트 -->
  <div class="admake-crop-left">
    <div class="admake-media-list">
      <div class="admake-media-list-header">
        <span class="admake-media-list-number font-inter">01</span>
        <span class="admake-media-list-title">미디어 목록</span>
      </div>
      <div class="admake-media-list-container" id="mediaListContainer"></div>
    </div>
  </div>

  <!-- 중앙: 크롭 캔버스 -->
  <div class="admake-crop-center">
    <div class="admake-canvas-wrapper">
      <!-- 비율 버튼 - 그리드 좌측에 밀착 -->
      <div class="admake-ratio-buttons-vertical" id="ratioButtonsVertical">
        <button class="admake-ratio-btn-v active-916" id="ratioBtn916v" data-ratio="9/16">9:16</button>
        <button class="admake-ratio-btn-v" id="ratioBtn45v" data-ratio="4/5">4:5</button>
        <button class="admake-ratio-btn-v" id="ratioBtn11v" data-ratio="1/1">1:1</button>
      </div>

      <div class="admake-guide-container ratio-916" id="guideContainer">
        <div class="admake-guide-preview" id="guidePreview">
          <canvas class="admake-crop-canvas" id="cropCanvas" style="display: none;"></canvas>
          <!-- 가이드라인 (비율에 따라 표시/숨김) -->
          <div class="admake-guide-line admake-guide-line-4-5"></div>
          <div class="admake-guide-line admake-guide-line-1-1"></div>
          <div id="videoNotice" class="admake-video-notice" style="display: none;">
            동영상은 9:16 권장 비율입니다
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 우측: 컨트롤 패널 -->
  <div class="admake-crop-right" id="cropControls">
    <!-- 원본 사이즈 선택 -->
    <div class="admake-control-section">
      <div class="admake-control-header">
        <span class="admake-control-number font-inter">01</span>
        <span class="admake-control-title">원본 사이즈 선택</span>
      </div>
      <div class="admake-ratio-buttons">
        <button class="admake-ratio-btn active" id="ratioBtn916" data-ratio="9/16">9:16</button>
        <button class="admake-ratio-btn" id="ratioBtn45" data-ratio="4/5">4:5</button>
        <button class="admake-ratio-btn" id="ratioBtn11" data-ratio="1/1">1:1</button>
      </div>
    </div>

    <!-- 확대 축소 -->
    <div class="admake-control-section">
      <div class="admake-control-header">
        <span class="admake-control-number font-inter">02</span>
        <span class="admake-control-title">확대 축소</span>
      </div>
      <div class="admake-zoom-control">
        <input type="range" id="zoomSlider" class="admake-zoom-slider" min="0.01" max="3" step="0.01" value="1">
        <span class="admake-zoom-value font-inter" id="zoomValue">100%</span>
      </div>
    </div>

    <!-- 해상도 표시 -->
    <div class="admake-control-section">
      <div class="admake-resolution-display" id="resolutionDisplay">
        <div class="admake-resolution-label">출력 해상도</div>
        <div class="admake-resolution-value font-inter" id="resolutionValue">-- x --</div>
        <div class="admake-resolution-status" id="resolutionStatus">✓ 메타 광고 권장 규격</div>
      </div>
      <div id="resolutionWarning" class="hidden" style="margin-top: 8px; padding: 12px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 8px; text-align: center;">
        <div style="font-size: 12px; color: var(--accent-red); font-weight: 600;">해상도가 너무 낮습니다</div>
        <div style="font-size: 11px; color: var(--accent-red); margin-top: 4px; opacity: 0.8;">최소 600px 이상 필요</div>
      </div>
    </div>

    <!-- 플랫폼 호환성 배지 -->
    <div id="platformCompatBadge" class="hidden" style="padding: 12px; border-radius: 8px; text-align: center; margin-bottom: 16px;">
      <div id="platformCompatText" style="font-size: 12px; font-weight: 600;"></div>
      <div id="platformCompatDetail" style="font-size: 11px; margin-top: 4px;"></div>
    </div>

    <!-- 확인 버튼 -->
    <button class="admake-confirm-btn" id="confirmBtn">
      확인 완료
    </button>
  </div>
</div>

<!-- 하단 액션 바 -->
<div class="admake-action-bar">
  <div class="admake-action-left font-inter">STEP 2 OF 5</div>
  <div class="admake-action-buttons">
    <button class="admake-btn admake-btn-secondary" id="backBtn">이전</button>
    <button class="admake-btn admake-btn-primary" id="uploadBtn" disabled>
      <span id="uploadBtnText">메타에 업로드</span>
      <span id="uploadBtnCount" style="display: none; margin-left: 8px; font-size: 11px; opacity: 0.8;"></span>
    </button>
  </div>
</div>

<!-- 로딩 오버레이 -->
<div class="admake-loading-overlay" id="loadingOverlay">
  <div class="admake-loading-content">
    <div class="admake-loading-spinner"></div>
    <div class="admake-loading-text">메타 서버에 소재를 등록 중입니다...</div>
    <div style="margin-top: 24px; width: 100%; max-width: 300px;">
      <div style="width: 100%; height: 4px; background: var(--bg-card); border-radius: 2px; overflow: hidden;">
        <div id="uploadProgressBar" style="height: 100%; background: var(--text-primary); width: 0%; transition: width 0.3s;"></div>
      </div>
      <div id="uploadProgressText" style="margin-top: 8px; font-size: 12px; color: var(--text-muted); text-align: center;">
        0 / 0 업로드 중...
      </div>
    </div>
  </div>
</div>

<!-- placeholderText 제거됨 -->

<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script src="{{ url_for('static', filename='js/common_ui.js') }}"></script>

<script>
// ✅ 상태 관리 - 개선된 구조
let mediaItems = []; // [{ id, name, type, mediaType, previewUrl, cropState: { x, y, zoom }, isConfirmed }]
let selectedMediaIndex = -1;
let uploadedResults = []; // 업로드 결과 { id, hash/video_id, type }
let videoAnimationFrame = null; // 동영상 애니메이션 프레임 ID
let isMediaLoading = false; // 미디어 로딩 중 플래그 (업로드 버튼 차단용)

// ✅ Canvas 관련 변수
let canvas, ctx;
let currentImage = null;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let currentX = 0;
let currentY = 0;
let currentZoom = 1;
let containerWidth = 0;
let containerHeight = 0;
let currentAspectRatio = 9/16; // 현재 선택된 비율 (9:16, 4:5, 1:1) - 디폴트 9:16
let minZoom = 1; // 최소 확대 배율 (동적 계산)

// ✅ [HD Export] 메타 광고 해상도 상수
const META_MIN_WIDTH = 600;        // 메타 광고 최소 너비
const META_RECOMMENDED_WIDTH = 1080; // 권장 너비
let currentCropPixelWidth = 0;     // 현재 크롭 영역의 원본 픽셀 너비
let currentCropPixelHeight = 0;    // 현재 크롭 영역의 원본 픽셀 높이

// ✅ [Instagram Reels] 비율 상수 - 정확한 소수점 정밀도
const RATIO_9_16 = 9 / 16;         // 0.5625 (인스타그램 릴스 필수)
const RATIO_4_5 = 4 / 5;           // 0.8 (페이스북 피드 전용)
const RATIO_1_1 = 1;               // 1.0 (정사각형)
const RATIO_TOLERANCE = 0.0001;    // 비율 비교 허용 오차

// ✅ IndexedDB에서 File 객체 가져오기
async function getFileFromIndexedDB(mediaId) {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) {
      reject(new Error('IndexedDB를 지원하지 않습니다'));
      return;
    }

    const dbName = 'admake_files';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['files'], 'readonly');
      const store = transaction.objectStore('files');
      const getRequest = store.get(mediaId);

      getRequest.onsuccess = () => {
        if (getRequest.result && getRequest.result.file) {
          resolve(getRequest.result.file);
        } else {
          reject(new Error('파일을 찾을 수 없습니다'));
        }
      };

      getRequest.onerror = () => reject(getRequest.error);
    };

    request.onerror = () => reject(request.error);
  });
}

// ✅ [전면 재수정] Blob URL 즉시 재생성 (모든 검증 로직 폐기)
// 핵심: file 객체가 있으면 무조건 URL.createObjectURL() 호출
async function regenerateBlobUrl(item) {
  // 1. item.file이 있으면 즉시 새 URL 생성
  if (item.file) {
    const newUrl = URL.createObjectURL(item.file);
    console.log(`[REGEN] File 객체로 새 Blob URL 생성: ${item.id}`);
    return newUrl;
  }

  // 2. file이 없으면 IndexedDB에서 가져와서 새 URL 생성
  const file = await getFileFromIndexedDB(item.id);
  item.file = file; // file 객체 저장
  const newUrl = URL.createObjectURL(file);
  console.log(`[REGEN] IndexedDB에서 복구 후 새 Blob URL 생성: ${item.id}`);
  return newUrl;
}

// ✅ STEP 2 초기화 함수 (데이터 복구 강화)
async function initStep2() {
  // mediaItems가 비어있으면 IndexedDB에서 복구
  if (mediaItems.length === 0) {
    console.log('[DEBUG] mediaItems가 비어있음 - IndexedDB에서 복구 시도');
    await loadStep1Data();
  }
}

// ✅ [전면 재수정] STEP 1에서 저장된 데이터 불러오기
// 핵심: IndexedDB에서 file 객체를 가져와서 무조건 새 Blob URL 생성
async function loadStep1Data() {
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (!step1Data) {
    alert('STEP 1 데이터를 찾을 수 없습니다. 처음부터 시작해주세요.');
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    return;
  }

  try {
    const data = JSON.parse(step1Data);

    // 각 미디어에 대해 IndexedDB에서 File 객체를 가져와서 새 Blob URL 생성
    const loadedItems = [];
    for (const item of data.mediaItems) {
      try {
        // IndexedDB에서 File 객체 가져오기
        const file = await getFileFromIndexedDB(item.id);
        // 무조건 새 Blob URL 생성 (검증 없이)
        const previewUrl = URL.createObjectURL(file);
        console.log(`[LOAD] ${item.id}: 새 Blob URL 생성 완료`);

        // ===== [Fix] mediaType 폴백: 없거나 잘못된 경우 file.type으로 판단 =====
        const resolvedMediaType = item.mediaType || (file.type.startsWith('video/') ? 'video' : 'image');
        console.log(`[LOAD] ${item.id}: mediaType=${item.mediaType} → resolved=${resolvedMediaType} (file.type=${file.type})`);

        loadedItems.push({
          id: item.id,
          name: item.name,
          size: item.size,
          type: item.type,
          mediaType: resolvedMediaType,
          previewUrl: previewUrl,
          file: file, // File 객체 저장 (필수!)
          cropState: item.cropState || null, // null이면 초기 자동 맞춤 적용
          isConfirmed: item.isConfirmed || false
        });
      } catch (e) {
        console.error(`[ERROR] ${item.id} 로드 실패:`, e);
        alert(`미디어 "${item.name}"을 불러올 수 없습니다. STEP 1로 돌아가서 다시 업로드해주세요.`);
        window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
        return;
      }
    }

    mediaItems = loadedItems;
    console.log(`[LOAD] ${mediaItems.length}개 미디어 로드 완료`);

    // 리스트 렌더링
    renderMediaList();

    // 첫 번째 미디어 즉시 선택 (await 후 실행되므로 DOM 준비됨)
    if (mediaItems.length > 0) {
      console.log('[LOAD] 첫 번째 미디어 즉시 선택');
      selectMedia(0);
    }
  } catch (e) {
    console.error('STEP 1 데이터 로드 실패:', e);
    alert('데이터를 불러오는 중 오류가 발생했습니다.');
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
}

// ✅ 미디어 리스트 렌더링
function renderMediaList() {
  const container = document.getElementById('mediaListContainer');
  container.innerHTML = '';

  mediaItems.forEach((item, index) => {
    const mediaItem = document.createElement('div');
    mediaItem.className = `admake-media-item ${selectedMediaIndex === index ? 'selected' : ''}`;
    mediaItem.setAttribute('data-index', index);
    
    let mediaElement = '';
    if (item.mediaType === 'video') {
      mediaElement = `<video src="${item.previewUrl}" class="admake-media-item-video" muted playsinline loop></video>`;
    } else {
      mediaElement = `<img src="${item.previewUrl}" class="admake-media-item-image" alt="${item.name}">`;
    }

    const checkedIcon = item.isConfirmed ? '✓' : '';
    const confirmedClass = item.isConfirmed ? 'confirmed' : '';
    
    mediaItem.innerHTML = `
      ${mediaElement}
      <div class="admake-media-item-badge">${item.mediaType === 'video' ? 'VIDEO' : 'IMAGE'}</div>
      <div class="admake-media-item-checked ${confirmedClass}">${checkedIcon}</div>
    `;

    mediaItem.addEventListener('click', () => {
      // [전면 재수정] 검증 없이 즉시 선택
      selectMedia(index);
    });

    container.appendChild(mediaItem);
  });
}

// ✅ Canvas 초기화
function initCanvas() {
  canvas = document.getElementById('cropCanvas');
  if (!canvas) return;

  ctx = canvas.getContext('2d');
  updateCanvasSize();

  // 리사이즈 이벤트 처리 (디바운스 적용)
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const prevContainerWidth = containerWidth;
      const prevContainerHeight = containerHeight;

      updateCanvasSize();

      if (currentImage && containerWidth > 0 && containerHeight > 0) {
        // ===== [핵심] 리사이즈 시 minZoom 재계산 =====
        // 컨테이너 크기가 변경되었으면 minZoom을 다시 계산
        if (prevContainerWidth !== containerWidth || prevContainerHeight !== containerHeight) {
          const newMinZoom = calculateInitialZoom(currentImage, containerWidth, containerHeight, currentAspectRatio);
          console.log(`[RESIZE] minZoom 재계산: ${minZoom.toFixed(6)} (컨테이너: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)})`);

          // 현재 zoom이 새로운 minZoom보다 작으면 조정
          if (currentZoom < minZoom) {
            currentZoom = minZoom;
            // 슬라이더 업데이트
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            if (zoomSlider) {
              const maxZoom = Math.max(minZoom * 3, 1);
              zoomSlider.min = minZoom;
              zoomSlider.max = maxZoom;
              zoomSlider.value = currentZoom;
            }
            if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
          }
        }
        drawImage();
      }
    }, 100); // 100ms 디바운스
  });
  
  // 드래그 이벤트
  canvas.addEventListener('mousedown', startDrag);
  canvas.addEventListener('mousemove', onDrag);
  canvas.addEventListener('mouseup', endDrag);
  canvas.addEventListener('mouseleave', endDrag);
  
  // 터치 이벤트 (모바일)
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    startDrag({
      clientX: touch.clientX,
      clientY: touch.clientY,
      target: canvas
    });
  });
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    onDrag({
      clientX: touch.clientX,
      clientY: touch.clientY
    });
  });
  
  canvas.addEventListener('touchend', endDrag);
}

// ✅ Canvas 크기 업데이트 (반응형 컨테이너 대응)
function updateCanvasSize() {
  const container = document.getElementById('guideContainer');
  if (!container) return false;

  // getBoundingClientRect()로 실제 렌더링된 크기 가져오기 (clientWidth보다 정확)
  const rect = container.getBoundingClientRect();
  containerWidth = rect.width;
  containerHeight = rect.height;

  // 컨테이너 크기가 유효하지 않으면 false 반환
  if (containerWidth <= 0 || containerHeight <= 0) {
    console.warn(`[WARN] 컨테이너 크기 무효: ${containerWidth}x${containerHeight}`);
    return false;
  }

  if (canvas) {
    canvas.width = containerWidth;
    canvas.height = containerHeight;
  }

  console.log(`[DEBUG] 컨테이너 크기 업데이트: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);
  return true;
}

// ✅ 드래그 시작
function startDrag(e) {
  if (!currentImage) return;
  isDragging = true;
  const rect = canvas.getBoundingClientRect();
  dragStartX = e.clientX - rect.left;
  dragStartY = e.clientY - rect.top;
  canvas.style.cursor = 'grabbing';
}

// ✅ 드래그 중 (restrictPosition: true 효과 적용)
function onDrag(e) {
  if (!isDragging || !currentImage) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const deltaX = x - dragStartX;
  const deltaY = y - dragStartY;
  
  // 임시로 위치 업데이트
  let newX = currentX + deltaX;
  let newY = currentY + deltaY;
  
  // restrictPosition: true 효과 - 경계 제한 적용
  const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
  const cropX = (containerWidth - cropArea.width) / 2;
  const cropY = (containerHeight - cropArea.height) / 2;
  
  const imageNaturalWidth = currentImage.naturalWidth || currentImage.width;
  const imageNaturalHeight = currentImage.naturalHeight || currentImage.height;
  const imgWidth = imageNaturalWidth * currentZoom;
  const imgHeight = imageNaturalHeight * currentZoom;
  
  // 상대 좌표 계산
  let relativeX = newX - cropX;
  let relativeY = newY - cropY;
  
  // 경계 제한 (이미지가 프레임 안으로 들어오지 못하게)
  const minRelativeX = Math.min(0, -(imgWidth - cropArea.width));
  const minRelativeY = Math.min(0, -(imgHeight - cropArea.height));
  
  // 엄격한 경계 적용
  relativeX = Math.max(minRelativeX, Math.min(0, relativeX));
  relativeY = Math.max(minRelativeY, Math.min(0, relativeY));
  
  // 절대 좌표로 변환
  currentX = cropX + relativeX;
  currentY = cropY + relativeY;
  
  dragStartX = x;
  dragStartY = y;
  
  drawImage();
}

// ✅ 드래그 종료 (상태 저장 + IndexedDB 동기화)
function endDrag() {
  if (isDragging) {
    isDragging = false;
    canvas.style.cursor = 'move';
    saveCropState();

    // IndexedDB 상태 동기화 (드래그 완료 시점에 저장)
    syncCropStateToIndexedDB();
  }
}

// ✅ 이미지/동영상 그리기 (restrictPosition: true 효과 - 여백 원천 차단)
function drawImage() {
  if (!currentImage || !ctx) return;

  // ===== [핵심] 이미지/동영상 원본 크기 캡처 =====
  // 이미지: naturalWidth/naturalHeight 사용
  // 동영상: videoWidth/videoHeight 사용
  let imageNaturalWidth, imageNaturalHeight;
  
  if (currentImage instanceof HTMLVideoElement) {
    // 동영상인 경우
    imageNaturalWidth = currentImage.videoWidth || currentImage.width || 1920;
    imageNaturalHeight = currentImage.videoHeight || currentImage.height || 1080;
  } else {
    // 이미지인 경우
    imageNaturalWidth = currentImage.naturalWidth || currentImage.width;
    imageNaturalHeight = currentImage.naturalHeight || currentImage.height;
  }

  if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
    console.error('[ERROR] drawImage: 미디어 원본 크기 무효');
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 선택된 비율에 맞는 크롭 영역 계산
  const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
  const cropX = (containerWidth - cropArea.width) / 2;
  const cropY = (containerHeight - cropArea.height) / 2;

  // ===== restrictPosition: true 효과 - 줌 강제 보정 =====
  // 현재 줌이 minZoom보다 작으면 강제로 minZoom으로 조정 (여백 원천 차단)
  if (currentZoom < minZoom) {
    console.log(`[RESTRICT] 줌 강제 보정: ${currentZoom.toFixed(6)} → ${minZoom.toFixed(6)}`);
    currentZoom = minZoom;
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomSlider) zoomSlider.value = currentZoom;
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
  }

  const imgWidth = imageNaturalWidth * currentZoom;
  const imgHeight = imageNaturalHeight * currentZoom;

  // ===== restrictPosition: true 효과 - 엄격한 경계 제한 =====
  // 이미지 경계가 프레임 안으로 들어오는 것을 절대 허용하지 않음
  // 1. 이미지 좌상단이 프레임 좌상단보다 우측/하단에 있으면 안됨 (좌측/상단 여백 방지)
  // 2. 이미지 우하단이 프레임 우하단보다 좌측/상단에 있으면 안됨 (우측/하단 여백 방지)

  // currentX, currentY를 크롭 영역 기준으로 조정
  let relativeX = currentX - cropX;
  let relativeY = currentY - cropY;

  // 경계 계산 (이미지가 프레임보다 클 때만 이동 가능)
  // 좌측/상단 경계: relativeX/Y <= 0
  // 우측/하단 경계: relativeX/Y >= -(imgWidth - cropArea.width)
  const minRelativeX = Math.min(0, -(imgWidth - cropArea.width));
  const minRelativeY = Math.min(0, -(imgHeight - cropArea.height));

  // 엄격한 경계 적용 (clamp)
  const finalX = Math.max(minRelativeX, Math.min(0, relativeX));
  const finalY = Math.max(minRelativeY, Math.min(0, relativeY));

  // 이미지를 크롭 영역에 맞춰 그리기 (clip 사용 - 프레임 밖 잘라내기)
  ctx.save();
  ctx.beginPath();
  ctx.rect(cropX, cropY, cropArea.width, cropArea.height);
  ctx.clip();

  // 이미지 또는 동영상을 Canvas에 그리기
  // drawImage는 이미지와 동영상 모두 지원
  ctx.drawImage(
    currentImage,
    cropX + finalX,
    cropY + finalY,
    imgWidth,
    imgHeight
  );
  
  // 동영상인 경우 현재 프레임을 계속 그리기 (애니메이션)
  if (currentImage instanceof HTMLVideoElement && currentImage.readyState >= 2) {
    // 동영상이 로드되었으면 다음 프레임도 그리기 위해 requestAnimationFrame 사용
    if (!videoAnimationFrame) {
      videoAnimationFrame = requestAnimationFrame(() => {
        videoAnimationFrame = null;
        if (currentImage instanceof HTMLVideoElement) {
          drawImage();
        }
      });
    }
  }

  ctx.restore();

  // currentX, currentY 업데이트 (절대 좌표로 저장)
  currentX = cropX + finalX;
  currentY = cropY + finalY;
}

// ✅ 크롭 상태 저장 (메모리 + sessionStorage)
function saveCropState() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];
    item.cropState = {
      x: currentX,
      y: currentY,
      zoom: currentZoom,
      aspectRatio: currentAspectRatio, // 비율도 저장
      minZoom: minZoom // minZoom도 저장 (복원 시 비교용)
    };
    // 상태 저장 시 자동으로 확인 처리하지 않음 (사용자가 명시적으로 확인해야 함)

    console.log(`[SAVE] 크롭 상태 저장: zoom=${currentZoom.toFixed(4)}, minZoom=${minZoom.toFixed(4)}, ratio=${currentAspectRatio}`);

    // sessionStorage에도 상태 저장 (페이지 새로고침 대비)
    const step1Data = sessionStorage.getItem('admake_step1_state');
    if (step1Data) {
      try {
        const data = JSON.parse(step1Data);
        const mediaItemIdx = data.mediaItems.findIndex(m => m.id === item.id);
        if (mediaItemIdx >= 0) {
          data.mediaItems[mediaItemIdx].cropState = item.cropState;
          data.mediaItems[mediaItemIdx].isConfirmed = item.isConfirmed;
          sessionStorage.setItem('admake_step1_state', JSON.stringify(data));
        }
      } catch (e) {
        console.warn('[SYNC] sessionStorage 동기화 실패:', e);
      }
    }
  }
}

// ✅ IndexedDB 상태 동기화 (비동기 - 끊김 방지)
async function syncCropStateToIndexedDB() {
  if (!('indexedDB' in window) || mediaItems.length === 0) return;

  try {
    const dbName = 'admake_files';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('files')) return;

      const transaction = db.transaction(['files'], 'readwrite');
      const store = transaction.objectStore('files');

      mediaItems.forEach(item => {
        if (item.file) {
          store.put({
            id: item.id,
            file: item.file,
            previewUrl: item.previewUrl,
            type: item.type,
            mediaType: item.mediaType,
            cropState: item.cropState,
            isConfirmed: item.isConfirmed
          });
        }
      });

      transaction.oncomplete = () => {
        console.log('[SYNC] IndexedDB 상태 동기화 완료');
      };
    };

    request.onerror = (e) => {
      console.warn('[SYNC] IndexedDB 열기 실패:', e);
    };
  } catch (e) {
    console.warn('[SYNC] IndexedDB 동기화 오류:', e);
  }
}

// ✅ 선택된 비율에 맞는 크롭 영역 크기 계산
function getCropAreaSize(containerWidth, containerHeight, aspectRatio) {
  let cropWidth, cropHeight;
  
  if (aspectRatio === 9/16) {
    // 9:16 - 전체 컨테이너 사용
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  } else if (aspectRatio === 4/5) {
    // 4:5 - 컨테이너 너비에 맞춤
    cropWidth = containerWidth;
    cropHeight = containerWidth / (4/5);
    if (cropHeight > containerHeight) {
      cropHeight = containerHeight;
      cropWidth = containerHeight * (4/5);
    }
  } else if (aspectRatio === 1/1) {
    // 1:1 - 정사각형
    const size = Math.min(containerWidth, containerHeight);
    cropWidth = size;
    cropHeight = size;
  } else {
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  }
  
  return { width: cropWidth, height: cropHeight };
}

// ✅ 고화질 이미지/동영상 대응: Cover Fit 최소 배율 계산 (여백 없이 프레임 꽉 채움)
function calculateInitialZoom(img, containerWidth, containerHeight, aspectRatio) {
  // ===== [핵심] 이미지/동영상 원본 크기 명시적 사용 =====
  // Image 객체: naturalWidth/naturalHeight 사용
  // Video 객체: videoWidth/videoHeight 사용
  let imageNaturalWidth, imageNaturalHeight;
  
  if (img instanceof HTMLVideoElement) {
    // 동영상인 경우
    imageNaturalWidth = img.videoWidth || img.width || 1920;
    imageNaturalHeight = img.videoHeight || img.height || 1080;
  } else {
    // 이미지인 경우
    imageNaturalWidth = img.naturalWidth || img.width;
    imageNaturalHeight = img.naturalHeight || img.height;
  }

  // 이미지 크기가 유효하지 않으면 기본값 반환
  if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
    console.error(`[ERROR] 이미지 원본 크기 무효: ${imageNaturalWidth}x${imageNaturalHeight}`);
    minZoom = 1;
    return 1;
  }

  const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);

  // 크롭 영역 크기가 유효하지 않으면 기본값 반환
  if (cropArea.width <= 0 || cropArea.height <= 0) {
    console.error(`[ERROR] 크롭 영역 크기 무효: ${cropArea.width}x${cropArea.height}`);
    minZoom = 1;
    return 1;
  }

  // ===== Cover Fit 계산 (핵심 로직) =====
  // 이미지 해상도에 관계없이 프레임을 여백 없이 꽉 채우는 최소 배율
  // 공식: minZoom = Math.max(frameWidth / imageWidth, frameHeight / imageHeight)
  const coverZoom = Math.max(
    cropArea.width / imageNaturalWidth,
    cropArea.height / imageNaturalHeight
  );

  // 최소 확대 비율 = Cover Fit 배율 (여백 원천 차단)
  // 이 값 이하로는 절대 축소 불가능 (restrictPosition: true 효과)
  // 고화질 이미지의 경우 minZoom이 매우 작을 수 있으므로 최소 0.001 보장
  minZoom = Math.max(0.001, coverZoom);

  console.log(`[MASTER FIX] Cover Fit 계산: 원본(${imageNaturalWidth}x${imageNaturalHeight}), 프레임(${cropArea.width.toFixed(0)}x${cropArea.height.toFixed(0)}), minZoom=${minZoom.toFixed(6)}`);

  // minZoom 값을 반환 (초기 배율로 사용)
  return minZoom;
}

// ✅ 크롭 상태 불러오기 (초기 화면 최적화: 9:16 디폴트, 여백 없이)
function loadCropState(item, img = null) {
  // 디폴트 비율을 9:16으로 설정 (초기 화면 최적화)
  if (!item.cropState || !item.cropState.aspectRatio) {
    currentAspectRatio = 9/16;
  } else {
    // 저장된 비율 복원
    currentAspectRatio = item.cropState.aspectRatio;
  }

  // ===== [핵심] 이미지/동영상 원본 크기 캡처 =====
  let imageNaturalWidth, imageNaturalHeight;
  
  if (img instanceof HTMLVideoElement) {
    // 동영상인 경우
    imageNaturalWidth = img.videoWidth || img.width || 1920;
    imageNaturalHeight = img.videoHeight || img.height || 1080;
  } else if (img) {
    // 이미지인 경우
    imageNaturalWidth = img.naturalWidth || img.width || 0;
    imageNaturalHeight = img.naturalHeight || img.height || 0;
  } else {
    imageNaturalWidth = 0;
    imageNaturalHeight = 0;
  }

  // ===== [핵심] 이미지/동영상이 있으면 무조건 minZoom 먼저 계산 =====
  // 이렇게 해야 저장된 상태 복원 시에도 올바른 minZoom이 적용됨
  if (img && containerWidth > 0 && containerHeight > 0 && imageNaturalWidth > 0 && imageNaturalHeight > 0) {
    // Cover Fit 최소 배율 계산 (여백 원천 차단)
    calculateInitialZoom(img, containerWidth, containerHeight, currentAspectRatio);
    console.log(`[MASTER FIX] minZoom 계산 완료: ${minZoom.toFixed(6)} (원본: ${imageNaturalWidth}x${imageNaturalHeight})`);
  }

  if (item && item.cropState && item.cropState.zoom > 0) {
    // 저장된 크롭 상태가 있으면 사용
    currentX = item.cropState.x;
    currentY = item.cropState.y;
    currentZoom = item.cropState.zoom;

    // ===== [핵심] 저장된 zoom이 minZoom보다 작으면 강제로 minZoom으로 조정 =====
    // 고화질 이미지의 경우 이전에 저장된 zoom 값이 현재 계산된 minZoom보다 작을 수 있음
    if (img && currentZoom < minZoom) {
      console.log(`[MASTER FIX] 저장된 zoom(${currentZoom.toFixed(6)})이 minZoom(${minZoom.toFixed(6)})보다 작음 → minZoom으로 강제 조정`);
      currentZoom = minZoom;

      // 위치도 중앙으로 재조정
      const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;
      const imgWidth = imageNaturalWidth * currentZoom;
      const imgHeight = imageNaturalHeight * currentZoom;
      currentX = cropX + (cropArea.width - imgWidth) / 2;
      currentY = cropY + (cropArea.height - imgHeight) / 2;
    }

    // 비율 버튼 상태 업데이트
    updateRatioButtons();
  } else {
    // 초기 상태 - 이미지가 선택된 비율 박스에 여백 없이 꽉 차게 자동 계산
    if (img && containerWidth > 0 && containerHeight > 0 && imageNaturalWidth > 0 && imageNaturalHeight > 0) {
      // 크롭 영역 계산
      const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;

      // ===== [핵심] 초기 배율 = Cover Fit 배율 (minZoom)으로 강제 설정 =====
      // img.onload에서 이미 계산했지만, loadCropState에서도 보장
      if (minZoom <= 0 || !isFinite(minZoom)) {
        // minZoom이 유효하지 않으면 재계산
        const calculatedMinZoom = Math.max(
          cropArea.width / imageNaturalWidth,
          cropArea.height / imageNaturalHeight
        );
        minZoom = Math.max(0.001, calculatedMinZoom);
      }
      currentZoom = minZoom;

      // 이미지를 크롭 영역 중앙에 배치
      const imgWidth = imageNaturalWidth * currentZoom;
      const imgHeight = imageNaturalHeight * currentZoom;
      currentX = cropX + (cropArea.width - imgWidth) / 2;
      currentY = cropY + (cropArea.height - imgHeight) / 2;

      console.log(`[MASTER FIX] 초기 배율 자동 설정: ${currentZoom.toFixed(6)} (Cover Fit, 원본 ${imageNaturalWidth}x${imageNaturalHeight})`);
    } else {
      currentX = 0;
      currentY = 0;
      currentZoom = 1;
      console.warn(`[WARN] 초기화 폴백: 컨테이너(${containerWidth}x${containerHeight}), 이미지(${imageNaturalWidth}x${imageNaturalHeight})`);
    }
  }

  // UI 업데이트 (슬라이더 범위 동적 설정: min=minZoom, max=minZoom*3)
  const zoomSlider = document.getElementById('zoomSlider');
  const zoomValue = document.getElementById('zoomValue');
  if (zoomSlider) {
    if (img && containerWidth > 0 && containerHeight > 0 && minZoom > 0) {
      // ===== 슬라이더 범위 동적 설정 =====
      // min: Cover Fit 배율 (이 이하로 축소 불가 - 여백 원천 차단)
      // max: minZoom * 3 (고화질 이미지에서도 부드러운 확대/축소)
      const maxZoom = Math.max(minZoom * 3, 1); // 최소 1 보장
      zoomSlider.min = minZoom;
      zoomSlider.max = maxZoom;
      zoomSlider.step = Math.max((maxZoom - minZoom) / 100, 0.0001); // 100단계로 분할, 최소 0.0001

      console.log(`[MASTER FIX] 슬라이더 범위 설정: min=${minZoom.toFixed(6)}, max=${maxZoom.toFixed(4)}, step=${zoomSlider.step}`);
    }
    zoomSlider.value = currentZoom;
  }
  if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

  // 비율 버튼 상태 업데이트
  updateRatioButtons();
}

// ✅ 비율 버튼 상태 업데이트
function updateRatioButtons() {
  const buttons = document.querySelectorAll('.admake-ratio-btn');
  const isVideo = isCurrentMediaVideo();

  buttons.forEach(btn => {
    const ratioStr = btn.getAttribute('data-ratio');
    const ratioValue = eval(ratioStr); // "9/16" -> 0.5625, "4/5" -> 0.8, "1/1" -> 1

    // 활성 상태 업데이트
    if (Math.abs(currentAspectRatio - ratioValue) < RATIO_TOLERANCE) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }

    // ✅ [UX 개선] 동영상도 모든 버튼 활성화 - 비활성화 스타일 제거
    btn.classList.remove('disabled-for-video');
    btn.style.opacity = '1';
    btn.style.cursor = 'pointer';

    // 툴팁은 동영상일 때 노출 위치 안내로 변경
    if (isVideo) {
      if (Math.abs(ratioValue - RATIO_9_16) < RATIO_TOLERANCE) {
        btn.title = '9:16 - 릴스/스토리/피드 모두 게재 가능';
      } else if (Math.abs(ratioValue - RATIO_4_5) < RATIO_TOLERANCE) {
        btn.title = '4:5 - 피드 전용 (릴스/스토리 불가)';
      } else {
        btn.title = '1:1 - 피드 전용 (릴스/스토리 불가)';
      }
    } else {
      btn.title = ratioStr === '9/16' ? '9:16 비율로 자르기' :
                  ratioStr === '4/5' ? '4:5 비율로 자르기' :
                  '1:1 비율로 자르기';
    }
  });

  // ✅ 플랫폼 호환성 배지 업데이트
  updateInstagramCompatibilityBadge();
}

// ✅ [UX 개선] 플랫폼 호환성 배지 업데이트 - 스마트 알림 방식
function updateInstagramCompatibilityBadge() {
  const badge = document.getElementById('platformCompatBadge');
  const textEl = document.getElementById('platformCompatText');
  const detailEl = document.getElementById('platformCompatDetail');

  if (!badge || !textEl || !detailEl) return;

  const isVideo = isCurrentMediaVideo();

  // 비율 판정
  const is916 = Math.abs(currentAspectRatio - RATIO_9_16) < RATIO_TOLERANCE;
  const is45 = Math.abs(currentAspectRatio - RATIO_4_5) < RATIO_TOLERANCE;
  const is11 = Math.abs(currentAspectRatio - RATIO_1_1) < RATIO_TOLERANCE;

  badge.style.display = 'block';

  if (is916) {
    // 9:16 - 모든 플랫폼 호환
    badge.style.background = '#ecfdf5';
    badge.style.border = '1px solid #a7f3d0';
    textEl.innerHTML = '✅ 릴스 + 스토리 + 피드 모두 게재 가능';
    textEl.style.color = '#059669';
    detailEl.innerHTML = '9:16 비율 (1080×1920)';
    detailEl.style.color = '#047857';
  } else if (is45) {
    // 4:5 - 피드 전용 (부드러운 안내)
    badge.style.background = '#f0f9ff';
    badge.style.border = '1px solid #bae6fd';
    textEl.innerHTML = '📱 피드 전용 (릴스/스토리 게재 불가)';
    textEl.style.color = '#0369a1';
    detailEl.innerHTML = '4:5 비율 (1080×1350) - 페이스북/인스타그램 피드에 최적화';
    detailEl.style.color = '#0c4a6e';
  } else if (is11) {
    // 1:1 - 피드 전용 (부드러운 안내)
    badge.style.background = '#f0f9ff';
    badge.style.border = '1px solid #bae6fd';
    textEl.innerHTML = '📱 피드 전용 (릴스/스토리 게재 불가)';
    textEl.style.color = '#0369a1';
    detailEl.innerHTML = '1:1 비율 (1080×1080) - 페이스북/인스타그램 피드에 최적화';
    detailEl.style.color = '#0c4a6e';
  } else {
    badge.style.display = 'none';
  }

  // 동영상일 때 추가 안내 (차단 아님, 정보 제공)
  if (isVideo && !is916) {
    badge.style.background = '#fefce8';
    badge.style.border = '1px solid #fde047';
    textEl.innerHTML = '📹 동영상: 피드 전용 광고로 제작됩니다';
    textEl.style.color = '#a16207';
    detailEl.innerHTML = is45 ? '4:5 비율 - 페이스북/인스타그램 피드 배치에 최적' :
                         is11 ? '1:1 비율 - 페이스북/인스타그램 피드 배치에 최적' :
                         '피드 배치 전용';
    detailEl.style.color = '#854d0e';
  }
}

// ✅ 가이드라인 표시/숨김 업데이트
function updateGuideLines() {
  const guide45 = document.querySelector('.admake-guide-line-4-5');
  const guide11 = document.querySelector('.admake-guide-line-1-1');
  
  if (guide45 && guide11) {
    // 선택된 비율에 따라 가이드라인 표시
    if (currentAspectRatio === 4/5) {
      guide45.classList.remove('hidden');
      guide11.classList.add('hidden');
    } else if (currentAspectRatio === 1/1) {
      guide45.classList.add('hidden');
      guide11.classList.remove('hidden');
    } else {
      // 9:16일 때는 둘 다 표시
      guide45.classList.remove('hidden');
      guide11.classList.remove('hidden');
    }
  }
}

// ✅ 비율 변경 처리 (실제 자르기 연동)
function changeAspectRatio(ratio) {
  // ✅ [UX 개선] 동영상도 모든 비율 허용 - 강제 변환 제거
  // 배지로 노출 위치 안내만 제공
  if (isCurrentMediaVideo() && Math.abs(ratio - RATIO_9_16) > RATIO_TOLERANCE) {
    console.log(`[FEED ONLY] 동영상 피드 전용 비율 적용: ${ratio}`);
  }

  currentAspectRatio = ratio;
  updateRatioButtons();
  updateGuideLines(); // 가이드라인 업데이트

  console.log(`[DEBUG] 비율 변경: ${ratio} (${ratio === 9/16 ? '9:16' : ratio === 4/5 ? '4:5' : '1:1'})`);

  if (currentImage && containerWidth > 0 && containerHeight > 0) {
    // ===== [핵심] 이미지/동영상 원본 크기 명시적 사용 =====
    let imageNaturalWidth, imageNaturalHeight;
    
    if (currentImage instanceof HTMLVideoElement) {
      imageNaturalWidth = currentImage.videoWidth || currentImage.width || 1920;
      imageNaturalHeight = currentImage.videoHeight || currentImage.height || 1080;
    } else {
      imageNaturalWidth = currentImage.naturalWidth || currentImage.width;
      imageNaturalHeight = currentImage.naturalHeight || currentImage.height;
    }

    if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
      console.error('[ERROR] changeAspectRatio: 미디어 원본 크기 무효');
      return;
    }

    // 새로운 비율에 맞는 크롭 영역 계산
    const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
    const cropX = (containerWidth - cropArea.width) / 2;
    const cropY = (containerHeight - cropArea.height) / 2;

    // 새로운 비율에 맞게 최소 배율 재계산
    calculateInitialZoom(currentImage, containerWidth, containerHeight, currentAspectRatio);

    // 현재 배율이 최소값보다 작으면 최소값으로 조정
    if (currentZoom < minZoom) {
      currentZoom = minZoom;
    }

    // 이미지 위치를 새로운 크롭 영역 중앙으로 조정
    const imgWidth = imageNaturalWidth * currentZoom;
    const imgHeight = imageNaturalHeight * currentZoom;

    // 이미지를 크롭 영역 중앙에 배치
    currentX = cropX + (cropArea.width - imgWidth) / 2;
    currentY = cropY + (cropArea.height - imgHeight) / 2;

    // 슬라이더 업데이트 (동적 범위: min=minZoom, max=minZoom*3)
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomSlider) {
      const maxZoom = Math.max(minZoom * 3, 1);
      zoomSlider.min = minZoom;
      zoomSlider.max = maxZoom;
      zoomSlider.step = Math.max((maxZoom - minZoom) / 100, 0.0001);
      zoomSlider.value = currentZoom;
    }
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

    // 이미지 다시 그리기
    drawImage();

    // 크롭 상태 저장
    saveCropState();

    // IndexedDB 상태 동기화
    syncCropStateToIndexedDB();

    // ✅ [HD Export] 실시간 해상도 표시 업데이트
    const cropPixels = calculateCropPixelSize(currentAspectRatio, currentZoom);
    updateResolutionDisplay(cropPixels.width, cropPixels.height);
  }
}

// ✅ 미디어 확인 처리 (토글 기능 - 확인/수정하기)
function confirmMedia() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];

    // 토글: 확인 → 수정 또는 수정 → 확인
    item.isConfirmed = !item.isConfirmed;
    saveCropState(); // 현재 크롭 상태 저장

    // 확인 버튼 상태 업데이트 (토글 기능)
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      if (item.isConfirmed) {
        // 확인됨 → "수정하기" 버튼으로 변경 (다시 클릭하면 수정 가능)
        confirmBtn.textContent = '수정하기';
        confirmBtn.classList.add('confirmed');
        confirmBtn.style.background = '#059669'; // 녹색
        console.log(`[CONFIRM] 미디어 ${item.id} 확인 완료 (수정하기 클릭 시 취소 가능)`);
      } else {
        // 수정 모드 → "이 미디어 확인 완료" 버튼으로 변경
        confirmBtn.textContent = '이 미디어 확인 완료';
        confirmBtn.classList.remove('confirmed');
        confirmBtn.style.background = '#111827'; // 기본 검정색
        console.log(`[CONFIRM] 미디어 ${item.id} 수정 모드로 전환`);
      }
    }

    renderMediaList();
    updateUploadButtonState();

    // IndexedDB 상태 동기화 (상태 유지 강화)
    syncCropStateToIndexedDB();
  }
}

// ✅ 미디어 선택 (미디어 변경 시 초기화 로직 포함)
async function selectMedia(index) {
  selectedMediaIndex = index;
  isMediaLoading = true; // 미디어 로딩 시작
  const item = mediaItems[index];
  
  // ===== [핵심] 미디어 변경 시 비율 초기화 =====
  // ===== [핵심] 미디어 변경 시 비율 초기화 =====
  // ✅ [UX 개선] 동영상도 저장된 비율 복원 (강제 9:16 제거)
  if (!item.cropState || !item.cropState.aspectRatio) {
    currentAspectRatio = RATIO_9_16; // 기본값은 9:16
    console.log(`[RATIO] 기본 비율 적용: 9:16`);
  } else {
    currentAspectRatio = item.cropState.aspectRatio;
    console.log(`[RATIO] 저장된 비율 복원: ${item.cropState.aspectRatio}`);
  }
  
  // 가이드 프리뷰 업데이트
  const preview = document.getElementById('guidePreview');
  const placeholder = document.getElementById('placeholderText');
  const videoNotice = document.getElementById('videoNotice');
  const cropControls = document.getElementById('cropControls');
  
  // 기존 미디어 제거
  let existingMedia = preview.querySelector('.admake-guide-preview-image, .admake-guide-preview-video');
  if (existingMedia) existingMedia.remove();
  
  // Canvas 초기화
  if (canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  
  if (item.mediaType === 'video') {
    // ===== [수정] 동영상 크롭 및 배율 조절 전면 허용 =====
    // 동영상도 이미지와 똑같이 배율 조절 로직 적용
    videoNotice.style.display = 'block'; // 작은 텍스트 안내만 표시
    cropControls.style.display = 'block'; // 크롭 컨트롤 항상 표시
    canvas.style.display = 'block'; // Canvas 항상 표시
    
    // 확인 버튼 표시
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'block';
      confirmBtn.disabled = false;
      if (item.isConfirmed) {
        confirmBtn.textContent = '수정하기';
        confirmBtn.classList.add('confirmed');
        confirmBtn.style.background = '#059669';
      } else {
        confirmBtn.textContent = '이 미디어 확인 완료';
        confirmBtn.classList.remove('confirmed');
        confirmBtn.style.background = '#111827';
      }
    }
    
    // ===== [전면 재수정] 모든 검증 로직 삭제, 동영상도 이미지와 동일 처리 =====
    // 동영상도 이미지처럼 Canvas에 그리기 위해 videoElement 생성
    const videoElement = document.createElement('video');
    videoElement.crossOrigin = 'anonymous';
    videoElement.src = item.previewUrl;
    videoElement.muted = true;
    videoElement.playsInline = true;
    videoElement.loop = true;
    videoElement.autoplay = true;
    
    // 동영상 로드 실패 시 file 객체로 즉시 재생성
    videoElement.onerror = async () => {
      console.warn(`[VIDEO ERROR] 동영상 로드 실패, 즉시 재생성: ${item.id}`);
      if (item.file) {
        item.previewUrl = URL.createObjectURL(item.file);
        videoElement.src = item.previewUrl;
      }
    };
    
    // ===== [Final Fix] 동영상 재생 준비 완료 시 Canvas에 그리기 =====
    // onloadedmetadata 대신 oncanplay 사용 (실제 프레임 그리기 가능 시점)
    videoElement.oncanplay = () => {
      currentImage = videoElement; // videoElement를 currentImage로 사용

      // 동영상 재생 시작 (Canvas에 프레임을 그리려면 재생 중이어야 함)
      videoElement.play().catch(e => {
        console.warn('[VIDEO] 자동 재생 실패 (사용자 상호작용 필요할 수 있음):', e);
      });

      // 컨테이너 준비 대기 + 즉시 강제 적용
      const applyVideoInitialFit = () => {
        // 컨테이너 크기 업데이트
        const containerReady = updateCanvasSize();

        if (!containerReady) {
          console.warn('[WAIT VIDEO] 컨테이너 준비 대기 중...');
          requestAnimationFrame(applyVideoInitialFit);
          return;
        }

        // 동영상 원본 크기
        const videoWidth = videoElement.videoWidth || 1920;
        const videoHeight = videoElement.videoHeight || 1080;

        console.log(`[VIDEO CANPLAY] 원본 크기: ${videoWidth}x${videoHeight}, 컨테이너: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);

        if (videoWidth > 0 && videoHeight > 0 && containerWidth > 0 && containerHeight > 0) {
          // 1. 9:16 비율로 강제 설정 (초기 로딩 시)
          if (!item.cropState || !item.cropState.aspectRatio) {
            currentAspectRatio = 9/16;
            updateRatioButtons();
            updateGuideLines();
          }

          // 2. 9:16 컨테이너에 빈틈없이 꽉 차는 최소 배율 계산
          const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
          const calculatedMinZoom = Math.max(
            cropArea.width / videoWidth,
            cropArea.height / videoHeight
          );

          // minZoom 값 업데이트
          minZoom = Math.max(0.001, calculatedMinZoom);

          console.log(`[AUTO-FIT VIDEO] 계산된 minZoom: ${minZoom.toFixed(6)} (원본: ${videoWidth}x${videoHeight}, 프레임: ${cropArea.width.toFixed(0)}x${cropArea.height.toFixed(0)})`);

          // 3. 초기 상태이거나 저장된 상태가 없으면 minZoom으로 강제 적용 및 좌표 리셋
          if (!item.cropState || !item.cropState.zoom || item.cropState.zoom < minZoom) {
            currentZoom = minZoom;
            console.log(`[AUTO-FIT VIDEO] 초기 zoom을 minZoom(${minZoom.toFixed(6)})으로 즉시 강제 설정`);

            // 좌표를 중앙에 꽉 차게 배치
            const cropX = (containerWidth - cropArea.width) / 2;
            const cropY = (containerHeight - cropArea.height) / 2;
            const vidWidth = videoWidth * currentZoom;
            const vidHeight = videoHeight * currentZoom;

            // 동영상을 크롭 영역 중앙에 배치
            currentX = cropX + (cropArea.width - vidWidth) / 2;
            currentY = cropY + (cropArea.height - vidHeight) / 2;

            console.log(`[AUTO-FIT VIDEO] 좌표 리셋: x=${currentX.toFixed(0)}, y=${currentY.toFixed(0)} (중앙 배치)`);
          }
        }

        // 크롭 상태 로드 및 슬라이더 업데이트
        loadCropState(item, videoElement);
        updateRatioButtons();
        updateGuideLines();

        // 슬라이더 범위 업데이트
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomValue = document.getElementById('zoomValue');
        if (zoomSlider && minZoom > 0) {
          const maxZoom = Math.max(minZoom * 3, 1);
          zoomSlider.min = minZoom;
          zoomSlider.max = maxZoom;
          zoomSlider.step = Math.max((maxZoom - minZoom) / 100, 0.0001);
          zoomSlider.value = currentZoom;
        }
        if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

        // 동영상 그리기 - 즉시 실행
        console.log(`[VIDEO DRAW] 동영상 Canvas 그리기 시작`);
        drawImage();
        isMediaLoading = false; // 동영상 로딩 완료
        console.log('[VIDEO] 미디어 로딩 완료');

        // ✅ [HD Export] 실시간 해상도 표시 업데이트
        const cropPixels = calculateCropPixelSize(currentAspectRatio, currentZoom);
        updateResolutionDisplay(cropPixels.width, cropPixels.height);
      };

      // 즉시 실행 시도
      applyVideoInitialFit();
    };

    // 동영상 로드 시작
    videoElement.load();
  } else {
    // ===== [안전장치] 타입 재검증 - file.type으로 video 여부 확인 =====
    const isActuallyVideo = item.file && item.file.type.startsWith('video/');
    if (isActuallyVideo) {
      console.warn(`[TYPE MISMATCH] mediaType=${item.mediaType}이지만 file.type=${item.file.type}. 동영상 분기로 강제 이동.`);
      item.mediaType = 'video';
      selectMedia(index); // 재호출하여 올바른 분기로 진입
      return;
    }

    // 이미지는 크롭 가능
    videoNotice.style.display = 'none';
    cropControls.style.display = 'block';
    
    // Canvas 표시
    canvas.style.display = 'block';
    
    // 확인 버튼 표시 및 상태 업데이트 (토글 버튼)
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'block';
      // 토글 버튼이므로 항상 활성화 상태
      confirmBtn.disabled = false;
      if (item.isConfirmed) {
        // 확인됨 → "수정하기" 버튼 표시
        confirmBtn.textContent = '수정하기';
        confirmBtn.classList.add('confirmed');
        confirmBtn.style.background = '#059669'; // 녹색
      } else {
        // 미확인 → "이 미디어 확인 완료" 버튼 표시
        confirmBtn.textContent = '이 미디어 확인 완료';
        confirmBtn.classList.remove('confirmed');
        confirmBtn.style.background = '#111827'; // 기본 검정색
      }
    }
    
    // 이미지 로드 (Blob URL 유효성 검사 포함)
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      currentImage = img;

      // ===== [수정] 컨테이너 준비 대기 + 즉시 강제 적용 =====
      const applyInitialFit = () => {
        // 컨테이너 크기 업데이트
        const containerReady = updateCanvasSize();

        if (!containerReady) {
          // 컨테이너가 아직 준비되지 않았으면 다음 프레임에서 재시도
          console.warn('[WAIT] 컨테이너 준비 대기 중...');
          requestAnimationFrame(applyInitialFit);
          return;
        }

        // naturalWidth/naturalHeight 로깅
        console.log(`[IMAGE LOADED] 원본 크기: ${img.naturalWidth}x${img.naturalHeight}, 컨테이너: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);

        // ===== [핵심] 초기 로딩 시 자동 맞춤 즉시 강제 적용 =====
        const imageNaturalWidth = img.naturalWidth || img.width;
        const imageNaturalHeight = img.naturalHeight || img.height;

        if (imageNaturalWidth > 0 && imageNaturalHeight > 0 && containerWidth > 0 && containerHeight > 0) {
          // 1. 9:16 비율로 강제 설정 (초기 로딩 시)
          if (!item.cropState || !item.cropState.aspectRatio) {
            currentAspectRatio = 9/16;
            updateRatioButtons();
            updateGuideLines();
          }

          // 2. 9:16 컨테이너에 빈틈없이 꽉 차는 최소 배율 계산
          const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
          const calculatedMinZoom = Math.max(
            cropArea.width / imageNaturalWidth,
            cropArea.height / imageNaturalHeight
          );

          // minZoom 값 업데이트
          minZoom = Math.max(0.001, calculatedMinZoom);

          console.log(`[AUTO-FIT] 계산된 minZoom: ${minZoom.toFixed(6)} (원본: ${imageNaturalWidth}x${imageNaturalHeight}, 프레임: ${cropArea.width.toFixed(0)}x${cropArea.height.toFixed(0)})`);

          // 3. 초기 상태이거나 저장된 상태가 없으면 minZoom으로 강제 적용 및 좌표 리셋
          // ===== [핵심] 무조건 가장 작은 사이즈(여백 없는 최소 배율) + 중앙 정렬이 디폴트 =====
          if (!item.cropState || !item.cropState.zoom || item.cropState.zoom < minZoom) {
            currentZoom = minZoom; // 즉시 적용
            console.log(`[AUTO-FIT] 초기 zoom을 minZoom(${minZoom.toFixed(6)})으로 즉시 강제 설정`);

            // 좌표를 중앙에 꽉 차게 배치
            const cropX = (containerWidth - cropArea.width) / 2;
            const cropY = (containerHeight - cropArea.height) / 2;
            const imgWidth = imageNaturalWidth * currentZoom;
            const imgHeight = imageNaturalHeight * currentZoom;

            // 이미지를 크롭 영역 중앙에 배치
            currentX = cropX + (cropArea.width - imgWidth) / 2;
            currentY = cropY + (cropArea.height - imgHeight) / 2;

            console.log(`[AUTO-FIT] 좌표 리셋: x=${currentX.toFixed(0)}, y=${currentY.toFixed(0)} (중앙 배치)`);
          }
        }

        // 크롭 상태 로드 (minZoom 계산 포함) - 즉시 실행
        loadCropState(item, img);
        // 비율 버튼 상태 업데이트
        updateRatioButtons();
        // 가이드라인 표시 업데이트
        updateGuideLines();
        // 이미지 그리기 - 즉시 실행
        drawImage();
        isMediaLoading = false; // 이미지 로딩 완료
        console.log('[IMAGE] 미디어 로딩 완료');

        // ✅ [HD Export] 실시간 해상도 표시 업데이트
        const cropPixels = calculateCropPixelSize(currentAspectRatio, currentZoom);
        updateResolutionDisplay(cropPixels.width, cropPixels.height);
      };

      // 즉시 실행 시도
      applyInitialFit();
    };
    // 이미지 로드 실패 시 file 객체로 즉시 재생성
    img.onerror = () => {
      // ===== [Fix] 동영상인데 이미지 분기로 잘못 들어온 경우 감지 - 무한 루프 방지 =====
      if (item.file && item.file.type.startsWith('video/')) {
        console.error(`[TYPE ERROR] ${item.id}는 동영상인데 이미지로 처리됨. mediaType=${item.mediaType}, file.type=${item.file.type}`);
        item.mediaType = 'video';
        // 무한 루프 방지 - 이미지 재로드 시도하지 않고 selectMedia 재호출
        selectMedia(selectedMediaIndex);
        return;
      }

      console.warn(`[IMAGE ERROR] 이미지 로드 실패, 즉시 재생성: ${item.id}`);
      if (item.file) {
        item.previewUrl = URL.createObjectURL(item.file);
        img.src = item.previewUrl;
      }
    };
    img.src = item.previewUrl;
  }
  
  renderMediaList();
}

// ✅ 업로드 버튼 상태 업데이트
function updateUploadButtonState() {
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadBtnText = document.getElementById('uploadBtnText');
  const uploadBtnCount = document.getElementById('uploadBtnCount');
  
  if (!uploadBtn) return;
  
  const confirmedCount = mediaItems.filter(item => item.isConfirmed).length;
  const totalCount = mediaItems.length;
  const allConfirmed = totalCount > 0 && confirmedCount === totalCount;
  const remainingCount = totalCount - confirmedCount;
  
  uploadBtn.disabled = !allConfirmed;
  
  // 버튼 텍스트 및 미완료 개수 표시
  if (uploadBtnText) {
    if (allConfirmed) {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) uploadBtnCount.style.display = 'none';
    } else {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) {
        uploadBtnCount.textContent = `${remainingCount}개 더 확인 필요`;
        uploadBtnCount.style.display = 'inline';
      }
    }
  }
}

// ✅ 이전 버튼 핸들러 함수
function handleBackButton() {
  console.log('[DEBUG] 이전 버튼 클릭됨');

  // Step 1 상태를 sessionStorage에 다시 저장 (크롭 상태 포함)
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (step1Data) {
    const data = JSON.parse(step1Data);
    // 크롭 상태 업데이트
    data.mediaItems = data.mediaItems.map(item => {
      const mediaItem = mediaItems.find(m => m.id === item.id);
      if (mediaItem) {
        return {
          ...item,
          cropState: mediaItem.cropState,
          isConfirmed: mediaItem.isConfirmed,
          previewUrl: mediaItem.previewUrl // 최신 Blob URL 저장
        };
      }
      return item;
    });
    sessionStorage.setItem('admake_step1_state', JSON.stringify(data));
    console.log('[DEBUG] Step 1로 돌아가기 - 상태 저장 완료');
  }

  // IndexedDB에 최신 상태 저장 (Step 1 복구용)
  if ('indexedDB' in window && mediaItems.length > 0) {
    try {
      const dbName = 'admake_files';
      const request = indexedDB.open(dbName, 1);
      request.onsuccess = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains('files')) {
          const transaction = db.transaction(['files'], 'readwrite');
          const store = transaction.objectStore('files');

          mediaItems.forEach(item => {
            if (item.file) {
              store.put({
                id: item.id,
                file: item.file,
                previewUrl: item.previewUrl,
                type: item.type,
                mediaType: item.mediaType,
                cropState: item.cropState,
                isConfirmed: item.isConfirmed
              });
            }
          });

          transaction.oncomplete = () => {
            console.log('[DEBUG] IndexedDB 업데이트 완료 - Step 1 복구 준비');
            window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
          };
        } else {
          window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
        }
      };
      request.onerror = () => {
        window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
      };
    } catch (e) {
      console.error('[ERROR] IndexedDB 업데이트 실패:', e);
      window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    }
  } else {
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
}

// ✅ 업로드 버튼
document.getElementById('uploadBtn').addEventListener('click', uploadToMeta);

// ✅ 줌 슬라이더 이벤트 (restrictPosition 효과 - minZoom 엄격 적용 + 중앙 앵커)
const zoomSlider = document.getElementById('zoomSlider');
if (zoomSlider) {
  zoomSlider.addEventListener('input', (e) => {
    let newZoom = parseFloat(e.target.value);

    // restrictPosition: true 효과 - minZoom 이하로 축소 불가
    if (newZoom < minZoom) {
      console.log(`[RESTRICT] 슬라이더 줌 강제 보정: ${newZoom.toFixed(4)} → ${minZoom.toFixed(4)}`);
      newZoom = minZoom;
      e.target.value = minZoom;
    }

    // ===== [중앙 앵커 고정] 줌 변경 시 크롭 영역 중심 기준으로 확대/축소 =====
    if (currentImage && currentZoom !== newZoom) {
      const oldZoom = currentZoom;

      // 크롭 영역 계산
      const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;

      // 크롭 영역의 중심점 (스크린 좌표)
      const centerScreenX = cropX + cropArea.width / 2;
      const centerScreenY = cropY + cropArea.height / 2;

      // 현재 중심에 있는 이미지의 원본 좌표 (naturalWidth/Height 기준)
      const imagePointX = (centerScreenX - currentX) / oldZoom;
      const imagePointY = (centerScreenY - currentY) / oldZoom;

      // 새 줌에서 같은 이미지 포인트가 중심에 오도록 좌표 재계산
      currentX = centerScreenX - (imagePointX * newZoom);
      currentY = centerScreenY - (imagePointY * newZoom);

      console.log(`[ZOOM ANCHOR] 중앙 기준 줌: ${oldZoom.toFixed(4)} → ${newZoom.toFixed(4)}, pos=(${currentX.toFixed(0)}, ${currentY.toFixed(0)})`);
    }

    currentZoom = newZoom;
    const zoomValue = document.getElementById('zoomValue');
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

    if (currentImage) {
      drawImage();
      saveCropState();

      // IndexedDB 상태 동기화 (상태 유지 강화)
      syncCropStateToIndexedDB();

      // ✅ [HD Export] 실시간 해상도 표시 업데이트
      const cropPixels = calculateCropPixelSize(currentAspectRatio, currentZoom);
      updateResolutionDisplay(cropPixels.width, cropPixels.height);
    }
  });
}

// ✅ 확인 버튼 이벤트
const confirmBtn = document.getElementById('confirmBtn');
if (confirmBtn) {
  confirmBtn.addEventListener('click', () => {
    confirmMedia();
  });
}

// ✅ [HD Export] 실시간 해상도 표시 업데이트
function updateResolutionDisplay(pixelWidth, pixelHeight) {
  const valueEl = document.getElementById('resolutionValue');
  const statusEl = document.getElementById('resolutionStatus');
  const warningEl = document.getElementById('resolutionWarning');
  const confirmBtn = document.getElementById('confirmBtn');

  if (!valueEl || !statusEl || !warningEl) return;

  // 전역 변수 업데이트
  currentCropPixelWidth = Math.round(pixelWidth);
  currentCropPixelHeight = Math.round(pixelHeight);

  // 해상도 값 표시
  valueEl.textContent = `${currentCropPixelWidth} x ${currentCropPixelHeight}`;

  // 상태 판정
  if (currentCropPixelWidth >= META_RECOMMENDED_WIDTH) {
    // ✅ 권장 규격 이상
    statusEl.textContent = '✓ 메타 광고 권장 규격';
    statusEl.style.color = '#059669';
    warningEl.style.display = 'none';
    if (confirmBtn) confirmBtn.disabled = false;
  } else if (currentCropPixelWidth >= META_MIN_WIDTH) {
    // ⚠️ 최소 규격 충족 (권장 미달)
    statusEl.textContent = '△ 최소 규격 충족 (권장: 1080px)';
    statusEl.style.color = '#d97706';
    warningEl.style.display = 'none';
    if (confirmBtn) confirmBtn.disabled = false;
  } else {
    // ❌ 최소 규격 미달
    statusEl.textContent = '✗ 해상도 부족';
    statusEl.style.color = '#dc2626';
    warningEl.style.display = 'block';
    if (confirmBtn) confirmBtn.disabled = true;
  }

  console.log(`[HD RESOLUTION] ${currentCropPixelWidth}x${currentCropPixelHeight} (min: ${META_MIN_WIDTH}, recommended: ${META_RECOMMENDED_WIDTH})`);
}

// ✅ [HD Export] 현재 크롭 영역의 원본 픽셀 크기 계산
function calculateCropPixelSize(aspectRatio, zoom) {
  if (!currentImage || containerWidth <= 0 || containerHeight <= 0 || zoom <= 0) {
    return { width: 0, height: 0 };
  }

  // UI 크롭 영역 계산
  const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);

  // 원본 픽셀 크기 = UI 크롭 영역 / 줌 배율
  // 줌이 높을수록 원본에서 작은 영역을 자르므로 해상도가 낮아짐
  const pixelWidth = cropArea.width / zoom;
  const pixelHeight = cropArea.height / zoom;

  return { width: pixelWidth, height: pixelHeight };
}

// ✅ [HD Export] 크롭된 이미지 생성 - 원본 해상도 유지
async function createCroppedImage(mediaItem) {
  return new Promise((resolve, reject) => {
    if (mediaItem.mediaType === 'video') {
      // 동영상은 원본 파일 사용 (file 객체 우선)
      console.log(`[HD EXPORT] 동영상 원본 사용: ${mediaItem.id}`);
      if (mediaItem.file) {
        resolve(mediaItem.file);
        return;
      }
      // file 객체가 없으면 IndexedDB에서 가져오기
      getFileFromIndexedDB(mediaItem.id)
        .then(file => resolve(file))
        .catch(reject);
      return;
    }

    // ===== [HD Export] 이미지 고화질 크롭 =====
    const state = mediaItem.cropState || { x: 0, y: 0, zoom: 1, aspectRatio: 9/16 };
    const aspectRatio = state.aspectRatio || 9/16;
    const zoom = state.zoom || 1;

    // 이미지 로드
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      // 원본 이미지 크기
      const imageNaturalWidth = img.naturalWidth || img.width;
      const imageNaturalHeight = img.naturalHeight || img.height;

      if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
        reject(new Error('이미지 원본 크기를 가져올 수 없습니다'));
        return;
      }

      // UI 크롭 영역 계산 (containerWidth/Height는 전역 변수)
      const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;

      // ===== [핵심] 원본 이미지 좌표로 변환 =====
      // UI에서 크롭 영역의 시작점 (이미지 기준 상대 좌표)
      // state.x, state.y는 이미지가 캔버스에 그려지는 위치
      // cropX, cropY는 크롭 영역이 캔버스에서 시작되는 위치
      // 크롭 영역 기준 이미지 오프셋 = cropX - state.x (양수면 이미지 왼쪽 잘림)
      const offsetX = cropX - state.x;
      const offsetY = cropY - state.y;

      // 원본 이미지에서의 소스 좌표 (UI 좌표를 줌으로 나눔)
      const sx = Math.max(0, offsetX / zoom);
      const sy = Math.max(0, offsetY / zoom);
      const sw = Math.min(imageNaturalWidth - sx, cropArea.width / zoom);
      const sh = Math.min(imageNaturalHeight - sy, cropArea.height / zoom);

      // 출력 캔버스 크기 = 원본 픽셀 크기 (1:1 해상도)
      let outputWidth = Math.round(sw);
      let outputHeight = Math.round(sh);

      // ✅ [Instagram Reels] 9:16 비율 정밀도 보정 (0.5625 정확도)
      // Meta API는 비율이 미세하게 틀어지면 거부함
      const is916Ratio = Math.abs(aspectRatio - RATIO_9_16) < RATIO_TOLERANCE;
      if (is916Ratio) {
        // 9:16 = 0.5625 → width = height * 0.5625
        // 높이 기준으로 너비 재계산 (1920 → 1080)
        const exactWidth = Math.round(outputHeight * RATIO_9_16);
        if (outputWidth !== exactWidth) {
          console.log(`[RATIO FIX] 9:16 정밀도 보정: ${outputWidth}x${outputHeight} → ${exactWidth}x${outputHeight}`);
          outputWidth = exactWidth;
        }
        // 실제 비율 검증
        const actualRatio = outputWidth / outputHeight;
        console.log(`[RATIO CHECK] 9:16 비율 확인: ${actualRatio.toFixed(6)} (목표: ${RATIO_9_16.toFixed(6)})`);
      }

      // 4:5 비율도 정밀도 보정
      const is45Ratio = Math.abs(aspectRatio - RATIO_4_5) < RATIO_TOLERANCE;
      if (is45Ratio) {
        const exactWidth = Math.round(outputHeight * RATIO_4_5);
        if (outputWidth !== exactWidth) {
          console.log(`[RATIO FIX] 4:5 정밀도 보정: ${outputWidth}x${outputHeight} → ${exactWidth}x${outputHeight}`);
          outputWidth = exactWidth;
        }
      }

      // 1:1 비율도 정밀도 보정
      const is11Ratio = Math.abs(aspectRatio - RATIO_1_1) < RATIO_TOLERANCE;
      if (is11Ratio) {
        // 1:1은 너비와 높이가 같아야 함
        const maxDim = Math.max(outputWidth, outputHeight);
        const minDim = Math.min(outputWidth, outputHeight);
        if (outputWidth !== outputHeight) {
          console.log(`[RATIO FIX] 1:1 정밀도 보정: ${outputWidth}x${outputHeight} → ${minDim}x${minDim}`);
          outputWidth = minDim;
          outputHeight = minDim;
        }
      }

      console.log(`[HD EXPORT] 원본: ${imageNaturalWidth}x${imageNaturalHeight}`);
      console.log(`[HD EXPORT] 줌: ${zoom.toFixed(4)}, 소스: (${sx.toFixed(1)}, ${sy.toFixed(1)}) ${sw.toFixed(1)}x${sh.toFixed(1)}`);
      console.log(`[HD EXPORT] 출력: ${outputWidth}x${outputHeight} (비율: ${(outputWidth/outputHeight).toFixed(6)})`);

      // ===== 고화질 캔버스 생성 =====
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = outputWidth;
      cropCanvas.height = outputHeight;
      const cropCtx = cropCanvas.getContext('2d');

      // 고화질 렌더링 설정
      cropCtx.imageSmoothingEnabled = true;
      cropCtx.imageSmoothingQuality = 'high';

      // drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh)
      // 원본 이미지의 (sx, sy)부터 (sw, sh) 영역을
      // 캔버스의 (0, 0)부터 (outputWidth, outputHeight)로 그림
      cropCtx.drawImage(
        img,
        sx, sy, sw, sh,           // 소스 영역 (원본 픽셀)
        0, 0, outputWidth, outputHeight  // 대상 영역 (캔버스)
      );

      // Canvas를 Blob으로 변환 (JPEG 품질 0.95)
      cropCanvas.toBlob((blob) => {
        if (!blob) {
          reject(new Error('이미지 생성 실패'));
          return;
        }

        const file = new File([blob], mediaItem.name, { type: 'image/jpeg' });
        console.log(`[HD EXPORT] ✅ 완료: ${mediaItem.name} (${outputWidth}x${outputHeight}, ${(blob.size/1024).toFixed(1)}KB)`);
        resolve(file);
      }, 'image/jpeg', 0.95);
    };

    img.onerror = () => {
      reject(new Error('이미지를 불러올 수 없습니다'));
    };

    img.src = mediaItem.previewUrl;
  });
}

// ✅ 프로그레스 바 업데이트
function updateUploadProgress(current, total, fileName) {
  const progressBar = document.getElementById('uploadProgressBar');
  const progressText = document.getElementById('uploadProgressText');
  
  const percentage = Math.round((current / total) * 100);
  
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
  
  if (progressText) {
    progressText.textContent = `${current} / ${total} 업로드 중... ${fileName ? `(${fileName})` : ''}`;
  }
}

// ✅ 메타 API 업로드 (크롭된 이미지 사용, 순차 처리 및 프로그레스 바)
async function uploadToMeta() {
  // ===== [Fix] 미디어 로딩 중이면 업로드 차단 =====
  if (isMediaLoading) {
    alert('미디어 로딩 중입니다. 잠시 후 다시 시도해주세요.');
    console.warn('[UPLOAD] 미디어 로딩 중 - 업로드 차단됨');
    return;
  }

  const uploadBtn = document.getElementById('uploadBtn');
  const loadingOverlay = document.getElementById('loadingOverlay');

  uploadBtn.disabled = true;
  loadingOverlay.classList.add('active');

  try {
    // 서버에서 액세스 토큰 가져오기
    const tokenResponse = await fetch('/dashboard/get_meta_token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ account_id: accountId })
    });
    
    const tokenData = await tokenResponse.json();
    if (tokenData.status !== 'success' || !tokenData.access_token) {
      throw new Error('Meta 액세스 토큰을 가져올 수 없습니다');
    }
    
    const accessToken = tokenData.access_token;
    const apiVersion = 'v24.0';
    const adAccountId = `act_${accountId}`;
    
    uploadedResults = [];
    const errors = [];
    const totalCount = mediaItems.length;

    // ===== [Fix] 업로드 전 모든 미디어의 mediaType 검증 및 previewUrl 갱신 =====
    for (const item of mediaItems) {
      if (item.file) {
        const expectedType = item.file.type.startsWith('video/') ? 'video' : 'image';
        if (item.mediaType !== expectedType) {
          console.warn(`[UPLOAD FIX] ${item.id} 타입 수정: ${item.mediaType} → ${expectedType}`);
          item.mediaType = expectedType;
        }
        // previewUrl 갱신 (blob: URL은 페이지 이동 시 무효화될 수 있음)
        if (item.previewUrl) {
          try { URL.revokeObjectURL(item.previewUrl); } catch (e) {}
        }
        item.previewUrl = URL.createObjectURL(item.file);
        console.log(`[UPLOAD] ${item.id}: previewUrl 갱신 완료, mediaType=${item.mediaType}`);
      }
    }

    // 각 미디어 파일을 순차적으로 Meta API로 업로드
    for (let i = 0; i < mediaItems.length; i++) {
      const item = mediaItems[i];
      
      try {
        // 프로그레스 바 업데이트
        updateUploadProgress(i, totalCount, item.name);
        
        // 크롭된 이미지 또는 원본 파일 가져오기
        let file;
        if (item.mediaType === 'image') {
          file = await createCroppedImage(item);
          // ✅ [HD Export] 업로드 직전 로깅 - 이미지 해상도 확인
          console.log(`[HD UPLOAD] 이미지 업로드 준비: ${item.name}`);
          console.log(`[HD UPLOAD] ↳ 파일 크기: ${(file.size / 1024).toFixed(1)}KB`);
          console.log(`[HD UPLOAD] ↳ 크롭 설정: zoom=${item.cropState?.zoom?.toFixed(4) || 'N/A'}, ratio=${item.cropState?.aspectRatio || 'N/A'}`);
        } else {
          // 동영상은 원본 사용
          try {
            file = await getFileFromIndexedDB(item.id);
          } catch (e) {
            const response = await fetch(item.previewUrl);
            const blob = await response.blob();
            file = new File([blob], item.name, { type: item.type });
          }

          // ✅ [Instagram Reels] 동영상 비율 검증 및 로깅
          const videoRatio = item.cropState?.aspectRatio || RATIO_9_16;
          const is916Video = Math.abs(videoRatio - RATIO_9_16) < RATIO_TOLERANCE;

          console.log(`[HD UPLOAD] 동영상 업로드 준비: ${item.name}`);
          console.log(`[HD UPLOAD] ↳ 파일 크기: ${(file.size / (1024 * 1024)).toFixed(2)}MB`);
          console.log(`[HD UPLOAD] ↳ 설정된 비율: ${videoRatio.toFixed(4)} (9:16=${RATIO_9_16.toFixed(4)})`);

          if (!is916Video) {
            console.warn(`[REELS WARNING] ⚠️ 동영상 ${item.name}의 비율이 9:16이 아닙니다!`);
            console.warn(`[REELS WARNING] 인스타그램 릴스에서 거부될 수 있습니다.`);
          } else {
            console.log(`[HD UPLOAD] ✅ 인스타그램 릴스 호환 (9:16)`);
          }
        }

        let result;
        if (item.mediaType === 'image') {
          // 이미지 업로드: POST /v24.0/{ad_account_id}/adimages
          const formData = new FormData();
          formData.append('file', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/adimages?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '이미지 업로드 실패');
          }
          
          // 응답 형식: { "images": { "image_name": { "hash": "..." } } }
          const imageName = Object.keys(data.images || {})[0];
          const hash = data.images?.[imageName]?.hash;
          if (!hash) {
            throw new Error('이미지 해시를 받을 수 없습니다');
          }
          
          // ✅ [UX 개선] 배치 호환성 데이터 추가
          const imageRatio = item.cropState?.aspectRatio || RATIO_9_16;
          const imageIs916 = Math.abs(imageRatio - RATIO_9_16) < RATIO_TOLERANCE;

          result = {
            id: item.id,
            type: 'image',
            hash: hash,
            video_id: null,
            // 배치 호환성 정보
            aspectRatio: imageRatio,
            placements: {
              reels: imageIs916,        // 9:16만 릴스 가능
              stories: imageIs916,      // 9:16만 스토리 가능
              feed: true,               // 모든 비율 피드 가능
              instream: imageIs916      // 9:16만 인스트림 가능
            }
          };
          console.log(`[PLACEMENT] 이미지 ${item.name}: reels=${imageIs916}, ratio=${imageRatio.toFixed(4)}`);
        } else {
          // 동영상 업로드: POST /v24.0/{ad_account_id}/advideos
          const formData = new FormData();
          formData.append('source', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/advideos?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '동영상 업로드 실패');
          }
          
          // 응답 형식: { "video_id": "..." }
          const videoId = data.video_id || data.id;
          if (!videoId) {
            throw new Error('동영상 ID를 받을 수 없습니다');
          }
          
          // ✅ [UX 개선] 배치 호환성 데이터 추가
          const videoRatio = item.cropState?.aspectRatio || RATIO_9_16;
          const videoIs916 = Math.abs(videoRatio - RATIO_9_16) < RATIO_TOLERANCE;

          result = {
            id: item.id,
            type: 'video',
            hash: null,
            video_id: videoId,
            // 배치 호환성 정보
            aspectRatio: videoRatio,
            placements: {
              reels: videoIs916,        // 9:16만 릴스 가능
              stories: videoIs916,      // 9:16만 스토리 가능
              feed: true,               // 모든 비율 피드 가능
              instream: videoIs916      // 9:16만 인스트림 가능
            }
          };
          console.log(`[PLACEMENT] 동영상 ${item.name}: reels=${videoIs916}, ratio=${videoRatio.toFixed(4)}`);
        }

        uploadedResults.push(result);
        
        // 마지막 항목 업로드 완료 시 프로그레스 바 100%
        if (i === mediaItems.length - 1) {
          updateUploadProgress(totalCount, totalCount, '완료');
        }
      } catch (error) {
        console.error(`미디어 ${item.id} 업로드 실패:`, error);
        errors.push({
          id: item.id,
          name: item.name,
          error: error.message
        });
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`${errors.length}개 파일 업로드 실패:\n${errors.map(e => `- ${e.name}: ${e.error}`).join('\n')}`);
    }
    
    // STEP 3으로 이동
    const step1Data = JSON.parse(sessionStorage.getItem('admake_step1_state'));
    sessionStorage.setItem('admake_step2_results', JSON.stringify({
      accountId: accountId,
      results: uploadedResults,
      landingUrl: step1Data.landingUrl
    }));
    
    alert('업로드 완료! STEP 3으로 이동합니다.');
    // window.location.href = `/admake/create/ad?account_id=${encodeURIComponent(accountId)}`;
    
  } catch (error) {
    console.error('업로드 오류:', error);
    if (confirm(`업로드 실패: ${error.message}\n\n재시도하시겠습니까?`)) {
      uploadBtn.disabled = false;
    } else {
      loadingOverlay.classList.remove('active');
    }
  } finally {
    if (uploadBtn.disabled) {
      loadingOverlay.classList.remove('active');
    }
  }
}

// ✅ [Instagram Reels] 동영상 비율 제한 경고 표시
function showVideoRatioWarning() {
  // 기존 경고 제거
  const existingWarning = document.getElementById('videoRatioWarning');
  if (existingWarning) existingWarning.remove();

  // 경고 툴팁 생성
  const warning = document.createElement('div');
  warning.id = 'videoRatioWarning';
  warning.innerHTML = `
    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: rgba(220, 38, 38, 0.95); color: white; padding: 20px 28px;
                border-radius: 12px; z-index: 9999; text-align: center;
                box-shadow: 0 8px 32px rgba(0,0,0,0.3); max-width: 320px;">
      <div style="font-size: 24px; margin-bottom: 8px;">⚠️</div>
      <div style="font-size: 15px; font-weight: 700; margin-bottom: 8px;">인스타그램 릴스 비율 제한</div>
      <div style="font-size: 13px; line-height: 1.5; opacity: 0.95;">
        동영상은 <strong>9:16 비율</strong>만 지원됩니다.<br>
        4:5, 1:1 비율은 인스타그램 릴스에서 거부됩니다.
      </div>
      <button onclick="this.parentElement.parentElement.remove()"
              style="margin-top: 16px; background: white; color: #dc2626; border: none;
                     padding: 8px 24px; border-radius: 6px; font-weight: 600; cursor: pointer;">
        확인
      </button>
    </div>
  `;
  document.body.appendChild(warning);

  // 3초 후 자동 제거
  setTimeout(() => {
    if (document.getElementById('videoRatioWarning')) {
      document.getElementById('videoRatioWarning').remove();
    }
  }, 3000);
}

// ✅ [Instagram Reels] 현재 미디어가 동영상인지 확인
function isCurrentMediaVideo() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    return mediaItems[selectedMediaIndex].mediaType === 'video';
  }
  return false;
}

// ✅ 비율 버튼 이벤트 등록 (가로 + 세로 버튼 동기화)
function setupRatioButtons() {
  // 모든 비율 버튼에 클릭 이벤트 등록 (가로, 세로 모두)
  const allRatioButtons = document.querySelectorAll('.admake-ratio-btn, .admake-ratio-btn-v');

  allRatioButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const ratioStr = btn.getAttribute('data-ratio');
      const ratio = eval(ratioStr); // "9/16" -> 0.5625, "4/5" -> 0.8, "1/1" -> 1

      // ✅ [UX 개선] 동영상도 모든 비율 허용 - 차단 없이 안내만
      if (isCurrentMediaVideo() && Math.abs(ratio - RATIO_9_16) > RATIO_TOLERANCE) {
        console.log(`[FEED ONLY] 동영상 피드 전용 비율 선택: ${ratioStr}`);
      }

      console.log(`[DEBUG] 비율 버튼 클릭: ${ratioStr} (${ratio})`);
      changeAspectRatio(ratio);

      // 모든 버튼 상태 동기화
      syncRatioButtonStates(ratioStr);
    });
  });
}

// ✅ 비율 버튼 상태 동기화 (가로/세로 버튼 + 캔버스 테두리)
function syncRatioButtonStates(ratioStr) {
  const guideContainer = document.getElementById('guideContainer');

  // 가로 버튼 업데이트
  document.querySelectorAll('.admake-ratio-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.getAttribute('data-ratio') === ratioStr) {
      btn.classList.add('active');
    }
  });

  // 세로 버튼 업데이트
  document.querySelectorAll('.admake-ratio-btn-v').forEach(btn => {
    btn.classList.remove('active-916', 'active-45', 'active-11');
    if (btn.getAttribute('data-ratio') === ratioStr) {
      if (ratioStr === '9/16') btn.classList.add('active-916');
      else if (ratioStr === '4/5') btn.classList.add('active-45');
      else if (ratioStr === '1/1') btn.classList.add('active-11');
    }
  });

  // 캔버스 테두리 색상 업데이트
  if (guideContainer) {
    guideContainer.classList.remove('ratio-916', 'ratio-45', 'ratio-11');
    if (ratioStr === '9/16') guideContainer.classList.add('ratio-916');
    else if (ratioStr === '4/5') guideContainer.classList.add('ratio-45');
    else if (ratioStr === '1/1') guideContainer.classList.add('ratio-11');
  }
}

// ✅ 초기화
document.addEventListener('DOMContentLoaded', async () => {
  initCanvas();

  // 비율 버튼 이벤트 등록
  setupRatioButtons();

  // ✅ 이전 버튼 이벤트 등록 (DOMContentLoaded 내부에서 확실하게 등록)
  const backBtn = document.getElementById('backBtn');
  if (backBtn) {
    backBtn.addEventListener('click', handleBackButton);
    console.log('[DEBUG] 이전 버튼 이벤트 등록 완료');
  } else {
    console.error('[ERROR] backBtn 요소를 찾을 수 없음');
  }

  // Step 2 초기화 (데이터 복구 강화)
  await initStep2();

  // 데이터가 없으면 로드 시도
  if (mediaItems.length === 0) {
    await loadStep1Data();
  }

  // 초기 가이드라인 표시
  updateGuideLines();

  updateUploadButtonState(); // 초기 버튼 상태 설정
});
</script>

</body>
</html>
