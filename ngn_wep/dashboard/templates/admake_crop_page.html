<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>크롭 및 가이드 - ADMAKE</title>
  <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='img/favicon.ico') }}">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}?v=1.4">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f9fafb;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      min-height: 100vh;
    }

    /* ✅ Progress Bar 스타일 */
    .admake-progress-bar {
      background: #ffffff;
      border-bottom: 1px solid #e5e7eb;
      padding: 24px 40px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .admake-progress-steps {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .admake-progress-step {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: #6b7280;
      letter-spacing: 0.05em;
    }

    .admake-progress-step.active {
      color: #111827;
    }

    .admake-progress-step.completed {
      color: #059669;
    }

    .admake-progress-connector {
      width: 40px;
      height: 2px;
      background: #e5e7eb;
      margin: 0 8px;
    }

    .admake-progress-connector.completed {
      background: #059669;
    }

    /* ✅ 메인 컨텐츠 영역 */
    .admake-crop-wrapper {
      max-width: 1600px;
      margin: 0 auto;
      padding: 40px;
      display: flex;
      gap: 32px;
    }

    .admake-crop-left {
      flex: 0 0 280px;
    }

    .admake-crop-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* ✅ 미디어 리스트 스타일 */
    .admake-media-list {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 1rem;
      padding: 16px;
      box-shadow: 8px 8px 0px 0px rgba(0, 0, 0, 0.03);
    }

    .admake-media-list-title {
      font-size: 14px;
      font-weight: 700;
      color: #111827;
      letter-spacing: 0.1em;
      margin-bottom: 16px;
      text-transform: uppercase;
    }

    .admake-media-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 0.75rem;
      overflow: hidden;
      background: #f3f4f6;
      border: 2px solid #e5e7eb;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 12px;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.02);
    }

    .admake-media-item:hover {
      border-color: #111827;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.04);
    }

    .admake-media-item.selected {
      border-color: #111827;
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.08);
    }

    .admake-media-item-image,
    .admake-media-item-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .admake-media-item-badge {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .admake-media-item-checked {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #111827;
      color: #ffffff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .admake-media-item.selected .admake-media-item-checked {
      opacity: 1;
    }

    .admake-media-item-checked.confirmed {
      opacity: 1;
      background: #059669;
    }

    /* ✅ 크롭 센터 영역 중앙 정렬 */
    .admake-crop-center {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: calc(100vh - 200px);
      padding: 40px 80px 40px 20px; /* 좌측 여백 추가 (라벨 공간) */
      position: relative;
    }

    /* ✅ 가이드 컨테이너 스타일 */
    .admake-guide-container {
      position: relative;
      width: 100%;
      max-width: 450px;
      aspect-ratio: 9 / 16;
      background: #f3f4f6;
      border: 2px solid #111827;
      border-radius: 1rem;
      overflow: visible; /* 라벨이 보이도록 변경 */
      box-shadow: 12px 12px 0px 0px rgba(0, 0, 0, 0.08);
      margin: 0 auto 32px;
      cursor: move;
      user-select: none;
      box-sizing: border-box; /* 보더 포함 크기 계산 */
      padding: 0; /* 패딩 제거로 정확한 계산 */
    }
    
    .admake-guide-preview {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden; /* 내부 콘텐츠만 클리핑 */
    }

    .admake-guide-preview {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    .admake-crop-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: move;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .admake-guide-preview-image,
    .admake-guide-preview-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .admake-video-notice {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17, 24, 39, 0.9);
      color: #ffffff;
      padding: 12px 24px;
      border-radius: 0.5rem;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.05em;
      z-index: 20;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.2);
    }

    /* ✅ 가이드 라인 스타일 */
    .admake-guide-line {
      position: absolute;
      border: 2px dashed rgba(17, 24, 39, 0.4);
      pointer-events: none;
      z-index: 12;
    }

    .admake-guide-line-4-5 {
      /* 4:5 비율 가이드 - 중앙 정렬 (수학적 정확도) */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 70.31%; /* 9:16 대비 4:5 세로 비율 */
      border: 2px dashed rgba(255, 255, 255, 0.5);
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    .admake-guide-line-1-1 {
      /* 1:1 비율 가이드 - 중앙 정사각형 (수학적 정확도) */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 56.25%; /* 9:16 대비 1:1 세로 비율 */
      border: 2px dashed rgba(255, 255, 255, 0.7);
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* ✅ 가이드 라벨 외부 배치 (좌측 바깥쪽) */
    .admake-guide-labels-container {
      position: absolute;
      left: -70px;
      top: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      z-index: 15;
      pointer-events: none;
    }

    .admake-guide-label {
      background: rgba(17, 24, 39, 0.9);
      color: #ffffff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.1em;
      white-space: nowrap;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
      margin-bottom: 4px;
    }

    .admake-guide-label-9-16 {
      /* 9:16 라벨 - 컨테이너 상단 (0%) */
      margin-top: 0;
    }

    .admake-guide-label-4-5 {
      /* 4:5 라벨 - 4:5 가이드 시작 높이 (50% - 35.155% = 14.845%) */
      margin-top: calc(14.845% - 12px); /* 라벨 높이 절반 보정 */
    }

    .admake-guide-label-1-1 {
      /* 1:1 라벨 - 1:1 가이드 시작 높이 (50% - 28.125% = 21.875%) */
      margin-top: calc(21.875% - 12px); /* 라벨 높이 절반 보정 */
    }

    /* ✅ 크롭 컨트롤 스타일 */
    .admake-crop-controls {
      margin-top: 24px;
      width: 100%;
      max-width: 450px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }

    /* ✅ 자르기 비율 버튼 그룹 */
    .admake-ratio-buttons {
      display: flex;
      gap: 8px;
      width: 100%;
      justify-content: center;
      margin-bottom: 8px;
    }

    .admake-ratio-btn {
      flex: 1;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.1em;
      border: 2px solid #111827;
      border-radius: 0.5rem;
      background: #ffffff;
      color: #111827;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-ratio-btn:hover {
      background: #f3f4f6;
      transform: translateY(-1px);
      box-shadow: 3px 3px 0px 0px rgba(0, 0, 0, 0.12);
    }

    .admake-ratio-btn.active {
      background: #111827;
      color: #ffffff;
      box-shadow: 3px 3px 0px 0px rgba(0, 0, 0, 0.15);
    }

    .admake-ratio-btn:active {
      transform: translateY(1px);
      box-shadow: 1px 1px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-zoom-control {
      display: flex;
      align-items: center;
      gap: 16px;
      width: 100%;
      margin-bottom: 0;
    }

    .admake-zoom-label {
      font-size: 12px;
      font-weight: 700;
      color: #111827;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      min-width: 60px;
    }

    .admake-zoom-slider {
      flex: 1;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .admake-zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #111827;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-zoom-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #111827;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-zoom-value {
      font-size: 12px;
      font-weight: 600;
      color: #6b7280;
      min-width: 40px;
      text-align: right;
    }

    /* ✅ 하단 액션 바 */
    .admake-action-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #ffffff;
      border-top: 1px solid #e5e7eb;
      padding: 20px 40px;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
    }

    .admake-action-buttons {
      display: flex;
      gap: 16px;
      margin-left: auto;
    }

    .admake-btn {
      padding: 14px 32px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.1em;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-btn-secondary {
      background: #f3f4f6;
      color: #6b7280;
    }

    .admake-btn-secondary:hover {
      background: #e5e7eb;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.12);
    }

    .admake-btn-primary {
      background: #111827;
      color: #ffffff;
    }

    .admake-btn-primary:hover:not(:disabled) {
      background: #1f2937;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.15);
    }

    .admake-btn-primary:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .admake-btn-primary #uploadBtnCount {
      display: inline-block;
      margin-left: 8px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0.8;
    }

    .admake-btn-primary:active:not(:disabled) {
      transform: translateY(2px);
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.1);
    }

    /* ✅ 로딩 오버레이 */
    .admake-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .admake-loading-overlay.active {
      display: flex;
    }

    .admake-loading-content {
      background: #ffffff;
      padding: 40px;
      border-radius: 1rem;
      text-align: center;
      box-shadow: 12px 12px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #f3f4f6;
      border-top: 4px solid #111827;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .admake-loading-text {
      font-size: 16px;
      font-weight: 600;
      color: #111827;
      letter-spacing: 0.05em;
    }

    /* ✅ 메인 컨텐츠 하단 여백 */
    .admake-crop-wrapper {
      padding-bottom: 100px;
    }

    /* ✅ 모바일 반응형 */
    @media (max-width: 1024px) {
      .admake-crop-wrapper {
        flex-direction: column;
        padding: 20px;
      }

      .admake-crop-left {
        flex: 1;
      }

      .admake-media-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 12px;
      }

      .admake-media-item {
        margin-bottom: 0;
      }
    }

    @media (max-width: 768px) {
      .admake-action-bar {
        padding: 16px 20px;
        flex-direction: column;
        gap: 12px;
      }

      .admake-action-buttons {
        width: 100%;
        margin-left: 0;
      }

      .admake-btn {
        flex: 1;
        padding: 12px 24px;
      }
    }
  </style>
</head>
<body>

<script>
  var userCompanyList = {{ session['company_names'] | tojson }};
  var currentUserId = "{{ session['user_id'] }}";
  var accountId = "{{ account_id }}";
</script>
<script src="{{ url_for('static', filename='js/mobile_detection.js') }}"></script>

<!-- ✅ 햄버거 메뉴 -->
<div class="nav-buttons">
  <div class="nav-left">
    <div id="updatedAtText" class="updated-at-text">크롭 및 가이드</div>
  </div>
  <div class="nav-right">
    <div class="hamburger-menu-wrapper">
      <div class="hamburger-icon" id="hamburgerIcon">
        <div></div><div></div><div></div>
      </div>
      <div class="hamburger-dropdown" id="hamburgerDropdown">
        <a href="/" class="{% if request.path == '/' %}active{% endif %}">사이트 성과</a>
        <a href="{{ url_for('ads_page') }}" class="{% if request.path == '/ads' %}active{% endif %}">광고 성과</a>
        <a href="{{ url_for('trend_selection_page') }}" class="{% if request.path.startswith('/trend') %}active{% endif %}">TREND</a>
        <a href="{{ url_for('auth.logout') }}">로그아웃</a>
      </div>
    </div>
  </div>
</div>

<!-- ✅ Progress Bar -->
<div class="admake-progress-bar">
  <div class="admake-progress-steps">
    <div class="admake-progress-step completed">STEP 1</div>
    <div class="admake-progress-connector completed"></div>
    <div class="admake-progress-step active">STEP 2</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 3</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 4</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 5</div>
  </div>
</div>

<!-- ✅ 메인 컨텐츠 -->
<div class="admake-crop-wrapper">
  <!-- 좌측: 미디어 리스트 -->
  <div class="admake-crop-left">
    <div class="admake-media-list">
      <div class="admake-media-list-title">미디어 목록</div>
      <div id="mediaListContainer"></div>
    </div>
  </div>

  <!-- 중앙: 가이드 컨테이너 -->
  <div class="admake-crop-center">
    <div class="admake-guide-container" id="guideContainer">
      <div class="admake-guide-preview" id="guidePreview">
        <canvas class="admake-crop-canvas" id="cropCanvas" style="display: none;"></canvas>
        <div class="admake-guide-line admake-guide-line-4-5"></div>
        <div class="admake-guide-line admake-guide-line-1-1"></div>
        <!-- 가이드 라벨 외부 배치 (좌측) -->
        <div class="admake-guide-labels-container">
          <div class="admake-guide-label admake-guide-label-9-16">9:16</div>
          <div class="admake-guide-label admake-guide-label-4-5">4:5</div>
          <div class="admake-guide-label admake-guide-label-1-1">1:1</div>
        </div>
        <div id="placeholderText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #9ca3af; font-size: 14px; text-align: center; z-index: 2; pointer-events: none;">
          미디어를 선택하세요
        </div>
        <div id="videoNotice" class="admake-video-notice" style="display: none;">
          동영상은 9:16 권장 비율입니다
        </div>
      </div>
    </div>
    
    <!-- 크롭 컨트롤 (이미지일 때만 표시) -->
    <div class="admake-crop-controls" id="cropControls" style="display: none;">
      <div class="admake-zoom-control">
        <span class="admake-zoom-label">확대/축소</span>
        <input type="range" id="zoomSlider" class="admake-zoom-slider" min="1" max="3" step="0.1" value="1">
        <span class="admake-zoom-value" id="zoomValue">100%</span>
      </div>
      <button class="admake-btn admake-btn-primary" id="confirmBtn" style="margin-top: 16px; width: 100%;">
        이 미디어 확인 완료
      </button>
    </div>
  </div>
</div>

<!-- ✅ 하단 액션 바 -->
<div class="admake-action-bar">
  <div></div>
  <div class="admake-action-buttons">
    <button class="admake-btn admake-btn-secondary" id="backBtn">이전</button>
    <button class="admake-btn admake-btn-primary" id="uploadBtn" disabled>
      <span id="uploadBtnText">메타에 업로드 하기</span>
      <span id="uploadBtnCount" style="display: none; margin-left: 8px; font-size: 12px; opacity: 0.8;"></span>
    </button>
  </div>
</div>

<!-- ✅ 로딩 오버레이 -->
<div class="admake-loading-overlay" id="loadingOverlay">
  <div class="admake-loading-content">
    <div class="admake-loading-spinner"></div>
    <div class="admake-loading-text">메타 서버에 소재를 등록 중입니다...</div>
    <div class="admake-progress-bar-container" style="margin-top: 24px; width: 100%; max-width: 400px;">
      <div class="admake-progress-bar-bg" style="width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden;">
        <div class="admake-progress-bar-fill" id="uploadProgressBar" style="height: 100%; background: #111827; width: 0%; transition: width 0.3s ease;"></div>
      </div>
      <div class="admake-progress-text" id="uploadProgressText" style="margin-top: 8px; font-size: 12px; color: #6b7280; text-align: center;">
        0 / 0 업로드 중...
      </div>
    </div>
  </div>
</div>

<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script src="{{ url_for('static', filename='js/common_ui.js') }}"></script>

<script>
// ✅ 상태 관리 - 개선된 구조
let mediaItems = []; // [{ id, name, type, mediaType, previewUrl, cropState: { x, y, zoom }, isConfirmed }]
let selectedMediaIndex = -1;
let uploadedResults = []; // 업로드 결과 { id, hash/video_id, type }

// ✅ Canvas 관련 변수
let canvas, ctx;
let currentImage = null;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let currentX = 0;
let currentY = 0;
let currentZoom = 1;
let containerWidth = 0;
let containerHeight = 0;
let currentAspectRatio = 9/16; // 현재 선택된 비율 (9:16, 4:5, 1:1)
let minZoom = 1; // 최소 확대 배율 (동적 계산)

// ✅ IndexedDB에서 File 객체 가져오기
async function getFileFromIndexedDB(mediaId) {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) {
      reject(new Error('IndexedDB를 지원하지 않습니다'));
      return;
    }

    const dbName = 'admake_files';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['files'], 'readonly');
      const store = transaction.objectStore('files');
      const getRequest = store.get(mediaId);

      getRequest.onsuccess = () => {
        if (getRequest.result && getRequest.result.file) {
          resolve(getRequest.result.file);
        } else {
          reject(new Error('파일을 찾을 수 없습니다'));
        }
      };

      getRequest.onerror = () => reject(getRequest.error);
    };

    request.onerror = () => reject(request.error);
  });
}

// ✅ Blob URL 유효성 검사 및 복구
async function validateAndRecoverBlobUrl(item) {
  // 기존 previewUrl이 유효한지 확인
  if (item.previewUrl) {
    try {
      const response = await fetch(item.previewUrl, { method: 'HEAD' });
      if (response.ok) {
        console.log(`[DEBUG] 기존 Blob URL 유효: ${item.id}`);
        return item.previewUrl;
      }
    } catch (e) {
      console.warn(`[WARN] 기존 Blob URL 유효하지 않음: ${item.id}`, e);
    }
  }
  
  // IndexedDB에서 File 객체 가져와서 새로운 Blob URL 생성
  try {
    const file = await getFileFromIndexedDB(item.id);
    const newPreviewUrl = URL.createObjectURL(file);
    console.log(`[DEBUG] 미디어 ${item.id} Blob URL 재생성 성공`);
    return newPreviewUrl;
  } catch (e) {
    console.error(`[ERROR] IndexedDB에서 ${item.id} 로드 실패:`, e);
    throw new Error(`미디어 ${item.id} 로드 실패`);
  }
}

// ✅ STEP 2 초기화 함수 (데이터 복구 강화)
async function initStep2() {
  // mediaItems가 비어있으면 IndexedDB에서 복구
  if (mediaItems.length === 0) {
    console.log('[DEBUG] mediaItems가 비어있음 - IndexedDB에서 복구 시도');
    await loadStep1Data();
  }
}

// ✅ STEP 1에서 저장된 데이터 불러오기 (Blob URL 복구)
async function loadStep1Data() {
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (!step1Data) {
    alert('STEP 1 데이터를 찾을 수 없습니다. 처음부터 시작해주세요.');
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    return;
  }

  try {
    const data = JSON.parse(step1Data);
    
    // 각 미디어에 대해 IndexedDB에서 File 객체를 가져와서 새로운 Blob URL 생성
    const loadedItems = await Promise.all(
      data.mediaItems.map(async (item) => {
        let previewUrl = null;
        let file = null;
        
        try {
          // IndexedDB에서 File 객체 가져오기
          file = await getFileFromIndexedDB(item.id);
          // 새로운 Blob URL 생성 (만료된 URL 대체)
          previewUrl = URL.createObjectURL(file);
          console.log(`[DEBUG] 미디어 ${item.id} Blob URL 재생성 성공`);
        } catch (e) {
          console.warn(`[WARN] IndexedDB에서 ${item.id} 로드 실패, 기존 URL 시도:`, e);
          
          // IndexedDB 실패 시 기존 previewUrl이 유효한지 확인
          try {
            const response = await fetch(item.previewUrl, { method: 'HEAD' });
            if (response.ok) {
              previewUrl = item.previewUrl;
              console.log(`[DEBUG] 기존 Blob URL 유효: ${item.id}`);
            } else {
              throw new Error('기존 URL도 유효하지 않음');
            }
          } catch (fetchError) {
            console.error(`[ERROR] 미디어 ${item.id} URL 복구 실패:`, fetchError);
            // URL 복구 실패 시 사용자에게 알림
            alert(`미디어 "${item.name}"을 불러올 수 없습니다. STEP 1로 돌아가서 다시 업로드해주세요.`);
            throw new Error(`미디어 ${item.id} 로드 실패`);
          }
        }
        
        // 저장된 크롭 상태 복원 (있는 경우)
        const savedCropState = item.cropState || { x: 0, y: 0, zoom: 1 };
        const savedIsConfirmed = item.isConfirmed || false;
        
        return {
          id: item.id,
          name: item.name,
          size: item.size,
          type: item.type,
          mediaType: item.mediaType,
          previewUrl: previewUrl,
          file: file, // File 객체 저장 (나중에 업로드 시 사용)
          cropState: savedCropState, // 저장된 크롭 상태 복원
          isConfirmed: savedIsConfirmed // 저장된 확인 상태 복원
        };
      })
    );
    
    mediaItems = loadedItems;
    console.log(`[DEBUG] ${mediaItems.length}개 미디어 로드 완료`);
    
    renderMediaList();
    
    // 첫 번째 미디어 자동 선택 및 즉시 표시
    if (mediaItems.length > 0) {
      console.log('[DEBUG] 첫 번째 미디어 자동 선택');
      // 약간의 지연을 두어 DOM이 완전히 렌더링된 후 선택
      setTimeout(() => {
        selectMedia(0);
      }, 100);
    }
  } catch (e) {
    console.error('STEP 1 데이터 로드 실패:', e);
    alert('데이터를 불러오는 중 오류가 발생했습니다: ' + e.message);
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
}

// ✅ 미디어 리스트 렌더링
function renderMediaList() {
  const container = document.getElementById('mediaListContainer');
  container.innerHTML = '';

  mediaItems.forEach((item, index) => {
    const mediaItem = document.createElement('div');
    mediaItem.className = `admake-media-item ${selectedMediaIndex === index ? 'selected' : ''}`;
    mediaItem.setAttribute('data-index', index);
    
    let mediaElement = '';
    if (item.mediaType === 'video') {
      mediaElement = `<video src="${item.previewUrl}" class="admake-media-item-video" muted playsinline loop></video>`;
    } else {
      mediaElement = `<img src="${item.previewUrl}" class="admake-media-item-image" alt="${item.name}">`;
    }

    const checkedIcon = item.isConfirmed ? '✓' : '';
    const confirmedClass = item.isConfirmed ? 'confirmed' : '';
    
    mediaItem.innerHTML = `
      ${mediaElement}
      <div class="admake-media-item-badge">${item.mediaType === 'video' ? 'VIDEO' : 'IMAGE'}</div>
      <div class="admake-media-item-checked ${confirmedClass}">${checkedIcon}</div>
    `;

    mediaItem.addEventListener('click', async () => {
      // 클릭 시 Blob URL 유효성 검사
      const clickedItem = mediaItems[index];
      if (clickedItem.mediaType === 'image') {
        try {
          // 미리 유효성 검사
          await validateAndRecoverBlobUrl(clickedItem).then(recoveredUrl => {
            if (recoveredUrl !== clickedItem.previewUrl) {
              clickedItem.previewUrl = recoveredUrl;
              // 리스트의 이미지도 업데이트
              const imgElement = mediaItem.querySelector('img');
              if (imgElement) {
                imgElement.src = recoveredUrl;
              }
            }
          });
        } catch (e) {
          console.error(`[ERROR] 미디어 ${clickedItem.id} URL 검증 실패:`, e);
          alert(`이미지 "${clickedItem.name}"을 불러올 수 없습니다.`);
          return;
        }
      }
      selectMedia(index);
    });

    container.appendChild(mediaItem);
  });
}

// ✅ Canvas 초기화
function initCanvas() {
  canvas = document.getElementById('cropCanvas');
  if (!canvas) return;
  
  ctx = canvas.getContext('2d');
  updateCanvasSize();
  
  // 리사이즈 이벤트 처리
  window.addEventListener('resize', () => {
    updateCanvasSize();
    if (currentImage) {
      drawImage();
    }
  });
  
  // 드래그 이벤트
  canvas.addEventListener('mousedown', startDrag);
  canvas.addEventListener('mousemove', onDrag);
  canvas.addEventListener('mouseup', endDrag);
  canvas.addEventListener('mouseleave', endDrag);
  
  // 터치 이벤트 (모바일)
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    startDrag({
      clientX: touch.clientX,
      clientY: touch.clientY,
      target: canvas
    });
  });
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    onDrag({
      clientX: touch.clientX,
      clientY: touch.clientY
    });
  });
  
  canvas.addEventListener('touchend', endDrag);
}

// ✅ Canvas 크기 업데이트
function updateCanvasSize() {
  const container = document.getElementById('guideContainer');
  if (!container) return;
  
  containerWidth = container.clientWidth;
  containerHeight = container.clientHeight;
  
  if (canvas) {
    canvas.width = containerWidth;
    canvas.height = containerHeight;
  }
}

// ✅ 드래그 시작
function startDrag(e) {
  if (!currentImage) return;
  isDragging = true;
  const rect = canvas.getBoundingClientRect();
  dragStartX = e.clientX - rect.left;
  dragStartY = e.clientY - rect.top;
  canvas.style.cursor = 'grabbing';
}

// ✅ 드래그 중
function onDrag(e) {
  if (!isDragging || !currentImage) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const deltaX = x - dragStartX;
  const deltaY = y - dragStartY;
  
  currentX += deltaX;
  currentY += deltaY;
  
  dragStartX = x;
  dragStartY = y;
  
  drawImage();
}

// ✅ 드래그 종료
function endDrag() {
  if (isDragging) {
    isDragging = false;
    canvas.style.cursor = 'move';
    saveCropState();
  }
}

// ✅ 이미지 그리기 (비율 제한 적용)
function drawImage() {
  if (!currentImage || !ctx) return;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // 선택된 비율에 맞는 크롭 영역 계산
  const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
  const cropX = (containerWidth - cropArea.width) / 2;
  const cropY = (containerHeight - cropArea.height) / 2;
  
  const imgWidth = currentImage.width * currentZoom;
  const imgHeight = currentImage.height * currentZoom;
  
  // 크롭 영역 내에서만 이미지가 보이도록 제한
  const maxX = Math.max(0, imgWidth - cropArea.width);
  const maxY = Math.max(0, imgHeight - cropArea.height);
  
  // currentX, currentY를 크롭 영역 기준으로 조정
  // currentX, currentY는 이미 크롭 영역 기준으로 저장되어 있음
  const relativeX = currentX - cropX;
  const relativeY = currentY - cropY;
  
  const finalX = Math.max(-maxX, Math.min(0, relativeX));
  const finalY = Math.max(-maxY, Math.min(0, relativeY));
  
  // 이미지를 크롭 영역에 맞춰 그리기 (clip 사용)
  ctx.save();
  ctx.beginPath();
  ctx.rect(cropX, cropY, cropArea.width, cropArea.height);
  ctx.clip();
  
  ctx.drawImage(
    currentImage,
    cropX + finalX,
    cropY + finalY,
    imgWidth,
    imgHeight
  );
  
  ctx.restore();
  
  // currentX, currentY 업데이트 (크롭 영역 기준)
  currentX = cropX + finalX;
  currentY = cropY + finalY;
}

// ✅ 크롭 상태 저장
function saveCropState() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];
    item.cropState = {
      x: currentX,
      y: currentY,
      zoom: currentZoom,
      aspectRatio: currentAspectRatio // 비율도 저장
    };
    // 상태 저장 시 자동으로 확인 처리하지 않음 (사용자가 명시적으로 확인해야 함)
  }
}

// ✅ 선택된 비율에 맞는 크롭 영역 크기 계산
function getCropAreaSize(containerWidth, containerHeight, aspectRatio) {
  let cropWidth, cropHeight;
  
  if (aspectRatio === 9/16) {
    // 9:16 - 전체 컨테이너 사용
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  } else if (aspectRatio === 4/5) {
    // 4:5 - 컨테이너 너비에 맞춤
    cropWidth = containerWidth;
    cropHeight = containerWidth / (4/5);
    if (cropHeight > containerHeight) {
      cropHeight = containerHeight;
      cropWidth = containerHeight * (4/5);
    }
  } else if (aspectRatio === 1/1) {
    // 1:1 - 정사각형
    const size = Math.min(containerWidth, containerHeight);
    cropWidth = size;
    cropHeight = size;
  } else {
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  }
  
  return { width: cropWidth, height: cropHeight };
}

// ✅ 이미지가 선택된 비율 박스에 맞게 초기 배율 및 최소 배율 계산
function calculateInitialZoom(img, containerWidth, containerHeight, aspectRatio) {
  const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);
  const imgAspect = img.width / img.height;
  const cropAspect = cropArea.width / cropArea.height;
  
  let initialZoom = 1;
  
  if (imgAspect > cropAspect) {
    // 이미지가 더 넓음 (가로형) - 높이에 맞춤
    initialZoom = cropArea.height / img.height;
  } else {
    // 이미지가 더 좁음 (세로형) - 너비에 맞춤
    initialZoom = cropArea.width / img.width;
  }
  
  // 최소 확대 비율 계산 (빈 공간이 보이지 않도록)
  minZoom = Math.max(
    cropArea.width / img.width,
    cropArea.height / img.height
  );
  
  // 최소값과 계산된 값 중 큰 값 사용
  initialZoom = Math.max(initialZoom, minZoom);
  
  // 최소값은 0.5, 최대값은 3으로 제한
  return Math.max(0.5, Math.min(initialZoom, 3));
}

// ✅ 크롭 상태 불러오기
function loadCropState(item, img = null) {
  if (item && item.cropState && item.cropState.zoom > 0) {
    // 저장된 크롭 상태가 있으면 사용
    currentX = item.cropState.x;
    currentY = item.cropState.y;
    currentZoom = item.cropState.zoom;
    // 저장된 비율도 복원 (있는 경우)
    if (item.cropState.aspectRatio) {
      currentAspectRatio = item.cropState.aspectRatio;
      updateRatioButtons();
    }
  } else {
    // 초기 상태 - 이미지가 선택된 비율 박스에 맞게 자동 계산
    currentX = 0;
    currentY = 0;
    
    if (img && containerWidth > 0 && containerHeight > 0) {
      currentZoom = calculateInitialZoom(img, containerWidth, containerHeight, currentAspectRatio);
      console.log(`[DEBUG] 초기 배율 자동 계산: ${currentZoom.toFixed(2)} (비율: ${currentAspectRatio})`);
    } else {
      currentZoom = 1;
    }
  }
  
  // UI 업데이트
  const zoomSlider = document.getElementById('zoomSlider');
  const zoomValue = document.getElementById('zoomValue');
  if (zoomSlider) {
    // 슬라이더 최소값 동적으로 조정
    if (img && containerWidth > 0 && containerHeight > 0) {
      zoomSlider.min = Math.max(0.5, minZoom * 0.9); // 최소값을 약간 여유있게
      zoomSlider.max = 3;
    }
    zoomSlider.value = currentZoom;
  }
  if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
}

// ✅ 비율 버튼 상태 업데이트
function updateRatioButtons() {
  const buttons = document.querySelectorAll('.admake-ratio-btn');
  buttons.forEach(btn => {
    const ratioStr = btn.getAttribute('data-ratio');
    const ratioValue = eval(ratioStr); // "9/16" -> 0.5625, "4/5" -> 0.8, "1/1" -> 1
    if (Math.abs(currentAspectRatio - ratioValue) < 0.001) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

// ✅ 비율 변경 처리
function changeAspectRatio(ratio) {
  currentAspectRatio = ratio;
  updateRatioButtons();
  
  if (currentImage && containerWidth > 0 && containerHeight > 0) {
    // 새로운 비율에 맞는 크롭 영역 계산
    const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
    const cropX = (containerWidth - cropArea.width) / 2;
    const cropY = (containerHeight - cropArea.height) / 2;
    
    // 새로운 비율에 맞게 최소 배율 재계산
    const newMinZoom = calculateInitialZoom(currentImage, containerWidth, containerHeight, currentAspectRatio);
    minZoom = newMinZoom;
    
    // 현재 배율이 최소값보다 작으면 최소값으로 조정
    if (currentZoom < minZoom) {
      currentZoom = minZoom;
    }
    
    // 이미지 위치를 새로운 크롭 영역 중앙으로 조정
    const imgWidth = currentImage.width * currentZoom;
    const imgHeight = currentImage.height * currentZoom;
    
    // 이미지를 크롭 영역 중앙에 배치
    currentX = cropX + (cropArea.width - imgWidth) / 2;
    currentY = cropY + (cropArea.height - imgHeight) / 2;
    
    // 슬라이더 업데이트
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomSlider) {
      zoomSlider.min = Math.max(0.5, minZoom * 0.9);
      zoomSlider.value = currentZoom;
    }
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
    
    // 이미지 다시 그리기
    drawImage();
    
    // 크롭 상태 저장
    saveCropState();
  }
}

// ✅ 미디어 확인 처리
function confirmMedia() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];
    item.isConfirmed = true;
    saveCropState(); // 현재 크롭 상태 저장
    
    // 확인 버튼 상태 업데이트
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.disabled = true;
      confirmBtn.textContent = '✓ 확인 완료';
    }
    
    renderMediaList();
    updateUploadButtonState();
  }
}

// ✅ 미디어 선택
async function selectMedia(index) {
  selectedMediaIndex = index;
  const item = mediaItems[index];
  
  // 가이드 프리뷰 업데이트
  const preview = document.getElementById('guidePreview');
  const placeholder = document.getElementById('placeholderText');
  const videoNotice = document.getElementById('videoNotice');
  const cropControls = document.getElementById('cropControls');
  
  // 기존 미디어 제거
  let existingMedia = preview.querySelector('.admake-guide-preview-image, .admake-guide-preview-video');
  if (existingMedia) existingMedia.remove();
  
  // Canvas 초기화
  if (canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  
  if (item.mediaType === 'video') {
    // 동영상은 크롭 불가, 미리보기만
    videoNotice.style.display = 'block';
    cropControls.style.display = 'none';
    canvas.style.display = 'none';
    
    // 확인 버튼 숨기기
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'none';
    }
    
    // 동영상은 자동으로 확인 처리 (크롭 불가능하므로)
    if (!item.isConfirmed) {
      item.isConfirmed = true;
      renderMediaList();
      updateUploadButtonState();
    }
    
    const videoElement = document.createElement('video');
    videoElement.className = 'admake-guide-preview-video';
    videoElement.src = item.previewUrl;
    videoElement.muted = true;
    videoElement.playsInline = true;
    videoElement.loop = true;
    videoElement.autoplay = true;
    videoElement.style.position = 'absolute';
    videoElement.style.top = '0';
    videoElement.style.left = '0';
    videoElement.style.width = '100%';
    videoElement.style.height = '100%';
    videoElement.style.objectFit = 'contain';
    videoElement.style.zIndex = '1';
    
    preview.appendChild(videoElement);
    currentImage = null;
  } else {
    // 이미지는 크롭 가능
    videoNotice.style.display = 'none';
    cropControls.style.display = 'block';
    
    // Canvas 표시
    canvas.style.display = 'block';
    
    // 확인 버튼 표시 및 상태 업데이트
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'block';
      confirmBtn.disabled = item.isConfirmed;
      confirmBtn.textContent = item.isConfirmed ? '✓ 확인 완료' : '이 미디어 확인 완료';
    }
    
    // 이미지 로드 (Blob URL 유효성 검사 포함)
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      currentImage = img;
      // Canvas 크기가 설정된 후에 크롭 상태 로드
      updateCanvasSize();
      loadCropState(item, img);
      // 비율 버튼 상태 업데이트
      updateRatioButtons();
      drawImage();
    };
    img.onerror = async () => {
      console.warn(`[WARN] 이미지 로드 실패, Blob URL 복구 시도: ${item.id}`);
      // Blob URL 복구 시도
      try {
        const recoveredUrl = await validateAndRecoverBlobUrl(item);
        item.previewUrl = recoveredUrl;
        // File 객체도 업데이트
        if (!item.file) {
          item.file = await getFileFromIndexedDB(item.id);
        }
        // 다시 로드 시도
        img.src = recoveredUrl;
      } catch (e) {
        console.error(`[ERROR] 이미지 복구 실패: ${item.id}`, e);
        alert(`이미지 "${item.name}"을 불러올 수 없습니다. STEP 1로 돌아가서 다시 업로드해주세요.`);
        canvas.style.display = 'none';
      }
    };
    img.src = item.previewUrl;
  }
  
  renderMediaList();
}

// ✅ 업로드 버튼 상태 업데이트
function updateUploadButtonState() {
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadBtnText = document.getElementById('uploadBtnText');
  const uploadBtnCount = document.getElementById('uploadBtnCount');
  
  if (!uploadBtn) return;
  
  const confirmedCount = mediaItems.filter(item => item.isConfirmed).length;
  const totalCount = mediaItems.length;
  const allConfirmed = totalCount > 0 && confirmedCount === totalCount;
  const remainingCount = totalCount - confirmedCount;
  
  uploadBtn.disabled = !allConfirmed;
  
  // 버튼 텍스트 및 미완료 개수 표시
  if (uploadBtnText) {
    if (allConfirmed) {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) uploadBtnCount.style.display = 'none';
    } else {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) {
        uploadBtnCount.textContent = `${remainingCount}개 더 확인 필요`;
        uploadBtnCount.style.display = 'inline';
      }
    }
  }
}

// ✅ 이전 버튼 (Step 1로 돌아가기 - 데이터 유지 및 IndexedDB 복구)
document.getElementById('backBtn').addEventListener('click', async () => {
  // Step 1 상태를 sessionStorage에 다시 저장 (크롭 상태 포함)
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (step1Data) {
    const data = JSON.parse(step1Data);
    // 크롭 상태 업데이트
    data.mediaItems = data.mediaItems.map(item => {
      const mediaItem = mediaItems.find(m => m.id === item.id);
      if (mediaItem) {
        return {
          ...item,
          cropState: mediaItem.cropState,
          isConfirmed: mediaItem.isConfirmed,
          previewUrl: mediaItem.previewUrl // 최신 Blob URL 저장
        };
      }
      return item;
    });
    sessionStorage.setItem('admake_step1_state', JSON.stringify(data));
    console.log('[DEBUG] Step 1로 돌아가기 - 상태 저장 완료');
  }
  
  // IndexedDB에 최신 상태 저장 (Step 1 복구용)
  if ('indexedDB' in window && mediaItems.length > 0) {
    try {
      const dbName = 'admake_files';
      const request = indexedDB.open(dbName, 1);
      request.onsuccess = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains('files')) {
          const transaction = db.transaction(['files'], 'readwrite');
          const store = transaction.objectStore('files');
          
          mediaItems.forEach(item => {
            if (item.file) {
              store.put({
                id: item.id,
                file: item.file,
                previewUrl: item.previewUrl,
                type: item.type,
                mediaType: item.mediaType,
                cropState: item.cropState,
                isConfirmed: item.isConfirmed
              });
            }
          });
          
          transaction.oncomplete = () => {
            console.log('[DEBUG] IndexedDB 업데이트 완료 - Step 1 복구 준비');
            // Blob URL은 revoke하지 않고 Step 1로 이동
            window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
          };
        } else {
          window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
        }
      };
      request.onerror = () => {
        window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
      };
    } catch (e) {
      console.error('[ERROR] IndexedDB 업데이트 실패:', e);
      window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    }
  } else {
    // Blob URL은 revoke하지 않고 Step 1로 이동
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
});

// ✅ 업로드 버튼
document.getElementById('uploadBtn').addEventListener('click', uploadToMeta);

// ✅ 줌 슬라이더 이벤트
const zoomSlider = document.getElementById('zoomSlider');
if (zoomSlider) {
  zoomSlider.addEventListener('input', (e) => {
    currentZoom = parseFloat(e.target.value);
    const zoomValue = document.getElementById('zoomValue');
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
    
    if (currentImage) {
      drawImage();
      saveCropState();
    }
  });
}

// ✅ 확인 버튼 이벤트
const confirmBtn = document.getElementById('confirmBtn');
if (confirmBtn) {
  confirmBtn.addEventListener('click', () => {
    confirmMedia();
  });
}

// ✅ 크롭된 이미지 생성 (Blob)
async function createCroppedImage(mediaItem) {
  return new Promise((resolve, reject) => {
    if (mediaItem.mediaType === 'video') {
      // 동영상은 원본 파일 사용
      getFileFromIndexedDB(mediaItem.id)
        .then(file => resolve(file))
        .catch(() => {
          // IndexedDB 실패 시 previewUrl에서 가져오기
          fetch(mediaItem.previewUrl)
            .then(res => res.blob())
            .then(blob => {
              const file = new File([blob], mediaItem.name, { type: mediaItem.type });
              resolve(file);
            })
            .catch(reject);
        });
      return;
    }
    
    // 이미지는 크롭된 버전 생성 (선택된 비율에 맞게)
    const state = mediaItem.cropState || { x: 0, y: 0, zoom: 1, aspectRatio: 9/16 };
    const aspectRatio = state.aspectRatio || 9/16;
    
    // 이미지 로드
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      // 선택된 비율에 맞는 크롭 영역 계산
      const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;
      
      // 크롭 캔버스 생성 (선택된 비율 크기)
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = cropArea.width;
      cropCanvas.height = cropArea.height;
      const cropCtx = cropCanvas.getContext('2d');
      
      const imgWidth = img.width * state.zoom;
      const imgHeight = img.height * state.zoom;
      
      // 크롭 영역 기준으로 이미지 위치 계산
      const relativeX = state.x - cropX;
      const relativeY = state.y - cropY;
      
      cropCtx.drawImage(
        img,
        relativeX,
        relativeY,
        imgWidth,
        imgHeight
      );
      
      // Canvas를 Blob으로 변환
      cropCanvas.toBlob((blob) => {
        if (!blob) {
          reject(new Error('이미지 생성 실패'));
          return;
        }
        
        const file = new File([blob], mediaItem.name, { type: 'image/jpeg' });
        resolve(file);
      }, 'image/jpeg', 0.95);
    };
    
    img.onerror = () => {
      reject(new Error('이미지를 불러올 수 없습니다'));
    };
    
    img.src = mediaItem.previewUrl;
  });
}

// ✅ 프로그레스 바 업데이트
function updateUploadProgress(current, total, fileName) {
  const progressBar = document.getElementById('uploadProgressBar');
  const progressText = document.getElementById('uploadProgressText');
  
  const percentage = Math.round((current / total) * 100);
  
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
  
  if (progressText) {
    progressText.textContent = `${current} / ${total} 업로드 중... ${fileName ? `(${fileName})` : ''}`;
  }
}

// ✅ 메타 API 업로드 (크롭된 이미지 사용, 순차 처리 및 프로그레스 바)
async function uploadToMeta() {
  const uploadBtn = document.getElementById('uploadBtn');
  const loadingOverlay = document.getElementById('loadingOverlay');
  
  uploadBtn.disabled = true;
  loadingOverlay.classList.add('active');

  try {
    // 서버에서 액세스 토큰 가져오기
    const tokenResponse = await fetch('/dashboard/get_meta_token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ account_id: accountId })
    });
    
    const tokenData = await tokenResponse.json();
    if (tokenData.status !== 'success' || !tokenData.access_token) {
      throw new Error('Meta 액세스 토큰을 가져올 수 없습니다');
    }
    
    const accessToken = tokenData.access_token;
    const apiVersion = 'v24.0';
    const adAccountId = `act_${accountId}`;
    
    uploadedResults = [];
    const errors = [];
    const totalCount = mediaItems.length;
    
    // 각 미디어 파일을 순차적으로 Meta API로 업로드
    for (let i = 0; i < mediaItems.length; i++) {
      const item = mediaItems[i];
      
      try {
        // 프로그레스 바 업데이트
        updateUploadProgress(i, totalCount, item.name);
        
        // 크롭된 이미지 또는 원본 파일 가져오기
        let file;
        if (item.mediaType === 'image') {
          file = await createCroppedImage(item);
        } else {
          // 동영상은 원본 사용
          try {
            file = await getFileFromIndexedDB(item.id);
          } catch (e) {
            const response = await fetch(item.previewUrl);
            const blob = await response.blob();
            file = new File([blob], item.name, { type: item.type });
          }
        }
        
        let result;
        if (item.mediaType === 'image') {
          // 이미지 업로드: POST /v24.0/{ad_account_id}/adimages
          const formData = new FormData();
          formData.append('file', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/adimages?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '이미지 업로드 실패');
          }
          
          // 응답 형식: { "images": { "image_name": { "hash": "..." } } }
          const imageName = Object.keys(data.images || {})[0];
          const hash = data.images?.[imageName]?.hash;
          if (!hash) {
            throw new Error('이미지 해시를 받을 수 없습니다');
          }
          
          result = {
            id: item.id,
            type: 'image',
            hash: hash,
            video_id: null
          };
        } else {
          // 동영상 업로드: POST /v24.0/{ad_account_id}/advideos
          const formData = new FormData();
          formData.append('source', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/advideos?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '동영상 업로드 실패');
          }
          
          // 응답 형식: { "video_id": "..." }
          const videoId = data.video_id || data.id;
          if (!videoId) {
            throw new Error('동영상 ID를 받을 수 없습니다');
          }
          
          result = {
            id: item.id,
            type: 'video',
            hash: null,
            video_id: videoId
          };
        }
        
        uploadedResults.push(result);
        
        // 마지막 항목 업로드 완료 시 프로그레스 바 100%
        if (i === mediaItems.length - 1) {
          updateUploadProgress(totalCount, totalCount, '완료');
        }
      } catch (error) {
        console.error(`미디어 ${item.id} 업로드 실패:`, error);
        errors.push({
          id: item.id,
          name: item.name,
          error: error.message
        });
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`${errors.length}개 파일 업로드 실패:\n${errors.map(e => `- ${e.name}: ${e.error}`).join('\n')}`);
    }
    
    // STEP 3으로 이동
    const step1Data = JSON.parse(sessionStorage.getItem('admake_step1_state'));
    sessionStorage.setItem('admake_step2_results', JSON.stringify({
      accountId: accountId,
      results: uploadedResults,
      landingUrl: step1Data.landingUrl
    }));
    
    alert('업로드 완료! STEP 3으로 이동합니다.');
    // window.location.href = `/admake/create/ad?account_id=${encodeURIComponent(accountId)}`;
    
  } catch (error) {
    console.error('업로드 오류:', error);
    if (confirm(`업로드 실패: ${error.message}\n\n재시도하시겠습니까?`)) {
      uploadBtn.disabled = false;
    } else {
      loadingOverlay.classList.remove('active');
    }
  } finally {
    if (uploadBtn.disabled) {
      loadingOverlay.classList.remove('active');
    }
  }
}

// ✅ 초기화
document.addEventListener('DOMContentLoaded', async () => {
  initCanvas();
  
  // Step 2 초기화 (데이터 복구 강화)
  await initStep2();
  
  // 데이터가 없으면 로드 시도
  if (mediaItems.length === 0) {
    await loadStep1Data();
  }
  
  updateUploadButtonState(); // 초기 버튼 상태 설정
});
</script>

</body>
</html>
