<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>크롭 및 가이드 - ADMAKE</title>
  <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='img/favicon.ico') }}">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}?v=1.4">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #f9fafb;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      min-height: 100vh;
    }

    /* ✅ Progress Bar 스타일 */
    .admake-progress-bar {
      background: #ffffff;
      border-bottom: 1px solid #e5e7eb;
      padding: 24px 40px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .admake-progress-steps {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .admake-progress-step {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      color: #6b7280;
      letter-spacing: 0.05em;
    }

    .admake-progress-step.active {
      color: #111827;
    }

    .admake-progress-step.completed {
      color: #059669;
    }

    .admake-progress-connector {
      width: 40px;
      height: 2px;
      background: #e5e7eb;
      margin: 0 8px;
    }

    .admake-progress-connector.completed {
      background: #059669;
    }

    /* ✅ 메인 컨텐츠 영역 */
    .admake-crop-wrapper {
      max-width: 1600px;
      margin: 0 auto;
      padding: 40px;
      display: flex;
      gap: 32px;
    }

    .admake-crop-left {
      flex: 0 0 280px;
    }

    .admake-crop-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* ✅ 미디어 리스트 스타일 */
    .admake-media-list {
      background: #ffffff;
      border: 1px solid #e5e7eb;
      border-radius: 1rem;
      padding: 16px;
      box-shadow: 8px 8px 0px 0px rgba(0, 0, 0, 0.03);
    }

    .admake-media-list-title {
      font-size: 14px;
      font-weight: 700;
      color: #111827;
      letter-spacing: 0.1em;
      margin-bottom: 16px;
      text-transform: uppercase;
    }

    .admake-media-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 0.75rem;
      overflow: hidden;
      background: #f3f4f6;
      border: 2px solid #e5e7eb;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 12px;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.02);
    }

    .admake-media-item:hover {
      border-color: #111827;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.04);
    }

    .admake-media-item.selected {
      border-color: #111827;
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.08);
    }

    .admake-media-item-image,
    .admake-media-item-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .admake-media-item-badge {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .admake-media-item-checked {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 24px;
      height: 24px;
      background: #111827;
      color: #ffffff;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 700;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .admake-media-item.selected .admake-media-item-checked {
      opacity: 1;
    }

    .admake-media-item-checked.confirmed {
      opacity: 1;
      background: #059669;
    }

    /* ✅ 크롭 센터 영역 중앙 정렬 */
    .admake-crop-center {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: calc(100vh - 200px);
      padding: 40px 20px;
      position: relative;
    }
    
    /* ✅ 가이드 라벨 외부 배치 (컨테이너 좌측 바깥) */
    .admake-guide-labels-wrapper {
      position: relative;
      width: 100%;
      max-width: 315px;
      margin: 0 auto;
    }
    
    .admake-guide-labels-container {
      position: absolute;
      left: -70px;
      top: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      z-index: 15;
      pointer-events: none;
    }

    /* ✅ 가이드 컨테이너 스타일 (크기 70%로 축소) */
    .admake-guide-container {
      position: relative;
      width: 100%;
      max-width: 315px; /* 450px의 70% */
      aspect-ratio: 9 / 16;
      background: #f3f4f6;
      border: 2px solid #111827;
      border-radius: 1rem;
      overflow: hidden; /* 내부 콘텐츠 클리핑 */
      box-shadow: 12px 12px 0px 0px rgba(0, 0, 0, 0.08);
      margin: 0 auto 32px;
      cursor: move;
      user-select: none;
      box-sizing: border-box; /* 보더 포함 크기 계산 */
      padding: 0; /* 패딩 제거로 정확한 계산 */
    }
    
    .admake-guide-preview {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden; /* 내부 콘텐츠만 클리핑 */
    }

    .admake-guide-preview {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    .admake-crop-canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: move;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }

    .admake-guide-preview-image,
    .admake-guide-preview-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .admake-video-notice {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(17, 24, 39, 0.9);
      color: #ffffff;
      padding: 12px 24px;
      border-radius: 0.5rem;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.05em;
      z-index: 20;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.2);
    }

    /* ✅ 가이드 라인 스타일 */
    .admake-guide-line {
      position: absolute;
      border: 2px dashed rgba(17, 24, 39, 0.4);
      pointer-events: none;
      z-index: 12;
    }

    .admake-guide-line-4-5 {
      /* 4:5 비율 가이드 - 완전한 박스 형태 */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 70.31%; /* 9:16 대비 4:5 세로 비율 */
      border: 2px dashed rgba(255, 255, 255, 0.6);
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      /* 모든 면에 border 표시 */
      border-top: 2px dashed rgba(255, 255, 255, 0.6);
      border-right: 2px dashed rgba(255, 255, 255, 0.6);
      border-bottom: 2px dashed rgba(255, 255, 255, 0.6);
      border-left: 2px dashed rgba(255, 255, 255, 0.6);
    }

    .admake-guide-line-1-1 {
      /* 1:1 비율 가이드 - 완전한 박스 형태 */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: 56.25%; /* 9:16 대비 1:1 세로 비율 */
      border: 2px dashed rgba(255, 255, 255, 0.8);
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      /* 모든 면에 border 표시 */
      border-top: 2px dashed rgba(255, 255, 255, 0.8);
      border-right: 2px dashed rgba(255, 255, 255, 0.8);
      border-bottom: 2px dashed rgba(255, 255, 255, 0.8);
      border-left: 2px dashed rgba(255, 255, 255, 0.8);
    }
    
    /* 선택된 비율에 따라 가이드라인 표시/숨김 */
    .admake-guide-line-4-5.hidden,
    .admake-guide-line-1-1.hidden {
      display: none;
    }

    /* ✅ 가이드 라벨 외부 배치 (좌측 바깥쪽) - 각 라벨 절대 위치 */
    .admake-guide-labels-container {
      position: absolute;
      left: -70px;
      top: 0;
      height: 100%;
      width: 60px;
      z-index: 15;
      pointer-events: none;
    }

    .admake-guide-label {
      position: absolute;
      left: 0;
      background: rgba(17, 24, 39, 0.9);
      color: #ffffff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.1em;
      white-space: nowrap;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-guide-label-9-16 {
      /* 9:16 라벨 - 컨테이너 상단 (0%) 가이드 박스 상단 정렬 */
      top: 0;
    }

    .admake-guide-label-4-5 {
      /* 4:5 라벨 - 4:5 가이드 상단 정렬 */
      /* 가이드라인 높이 70.31%, 중앙 정렬이므로 상단 = (100% - 70.31%) / 2 = 14.845% */
      top: 14.845%;
    }

    .admake-guide-label-1-1 {
      /* 1:1 라벨 - 1:1 가이드 상단 정렬 */
      /* 가이드라인 높이 56.25%, 중앙 정렬이므로 상단 = (100% - 56.25%) / 2 = 21.875% */
      top: 21.875%;
    }

    /* ✅ 크롭 컨트롤 스타일 (컨테이너와 동일한 너비, 화면 중앙 정렬) */
    .admake-crop-controls {
      margin-top: 24px;
      width: 100%;
      max-width: 315px; /* 컨테이너와 동일 */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* 내부 요소 중앙 정렬 */
      gap: 16px;
      margin-left: auto;
      margin-right: auto; /* 화면 중앙 배치 */
    }

    /* ✅ 자르기 비율 버튼 그룹 */
    .admake-ratio-buttons {
      display: flex;
      gap: 8px;
      width: 100%;
      justify-content: center;
      margin-bottom: 8px;
    }

    .admake-ratio-btn {
      flex: 1;
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.1em;
      border: 2px solid #111827;
      border-radius: 0.5rem;
      background: #ffffff;
      color: #111827;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-ratio-btn:hover {
      background: #f3f4f6;
      transform: translateY(-1px);
      box-shadow: 3px 3px 0px 0px rgba(0, 0, 0, 0.12);
    }

    .admake-ratio-btn.active {
      background: #111827;
      color: #ffffff;
      box-shadow: 3px 3px 0px 0px rgba(0, 0, 0, 0.15);
    }

    .admake-ratio-btn:active {
      transform: translateY(1px);
      box-shadow: 1px 1px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-zoom-control {
      display: flex;
      align-items: center;
      justify-content: center; /* 중앙 정렬 */
      gap: 16px;
      width: 100%;
      max-width: 315px; /* 컨테이너와 동일 */
      margin: 0 auto; /* 가로 중앙 */
      margin-bottom: 0;
    }

    .admake-zoom-label {
      font-size: 12px;
      font-weight: 700;
      color: #111827;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      min-width: 60px;
    }

    .admake-zoom-slider {
      flex: 1;
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .admake-zoom-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #111827;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-zoom-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #111827;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-zoom-value {
      font-size: 12px;
      font-weight: 600;
      color: #6b7280;
      min-width: 40px;
      text-align: right;
    }

    /* ✅ 하단 액션 바 */
    .admake-action-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #ffffff;
      border-top: 1px solid #e5e7eb;
      padding: 20px 40px;
      box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
    }

    .admake-action-buttons {
      display: flex;
      gap: 16px;
      margin-left: auto;
    }

    .admake-btn {
      padding: 14px 32px;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 0.1em;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      box-shadow: 4px 4px 0px 0px rgba(0, 0, 0, 0.1);
    }

    .admake-btn-secondary {
      background: #f3f4f6;
      color: #6b7280;
    }

    .admake-btn-secondary:hover {
      background: #e5e7eb;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.12);
    }

    .admake-btn-primary {
      background: #111827;
      color: #ffffff;
    }

    .admake-btn-primary:hover:not(:disabled) {
      background: #1f2937;
      transform: translateY(-2px);
      box-shadow: 6px 6px 0px 0px rgba(0, 0, 0, 0.15);
    }

    .admake-btn-primary:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .admake-btn-primary #uploadBtnCount {
      display: inline-block;
      margin-left: 8px;
      font-size: 12px;
      font-weight: 500;
      opacity: 0.8;
    }

    .admake-btn-primary:active:not(:disabled) {
      transform: translateY(2px);
      box-shadow: 2px 2px 0px 0px rgba(0, 0, 0, 0.1);
    }

    /* ✅ 로딩 오버레이 */
    .admake-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .admake-loading-overlay.active {
      display: flex;
    }

    .admake-loading-content {
      background: #ffffff;
      padding: 40px;
      border-radius: 1rem;
      text-align: center;
      box-shadow: 12px 12px 0px 0px rgba(0, 0, 0, 0.2);
    }

    .admake-loading-spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #f3f4f6;
      border-top: 4px solid #111827;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .admake-loading-text {
      font-size: 16px;
      font-weight: 600;
      color: #111827;
      letter-spacing: 0.05em;
    }

    /* ✅ 메인 컨텐츠 하단 여백 */
    .admake-crop-wrapper {
      padding-bottom: 100px;
    }

    /* ✅ 모바일 반응형 */
    @media (max-width: 1024px) {
      .admake-crop-wrapper {
        flex-direction: column;
        padding: 20px;
      }

      .admake-crop-left {
        flex: 1;
      }

      .admake-media-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap: 12px;
      }

      .admake-media-item {
        margin-bottom: 0;
      }
    }

    @media (max-width: 768px) {
      .admake-action-bar {
        padding: 16px 20px;
        flex-direction: column;
        gap: 12px;
      }

      .admake-action-buttons {
        width: 100%;
        margin-left: 0;
      }

      .admake-btn {
        flex: 1;
        padding: 12px 24px;
      }
    }
  </style>
</head>
<body>

<script>
  var userCompanyList = {{ session['company_names'] | tojson }};
  var currentUserId = "{{ session['user_id'] }}";
  var accountId = "{{ account_id }}";
</script>
<script src="{{ url_for('static', filename='js/mobile_detection.js') }}"></script>

<!-- ✅ 햄버거 메뉴 -->
<div class="nav-buttons">
  <div class="nav-left">
    <div id="updatedAtText" class="updated-at-text">크롭 및 가이드</div>
  </div>
  <div class="nav-right">
    <div class="hamburger-menu-wrapper">
      <div class="hamburger-icon" id="hamburgerIcon">
        <div></div><div></div><div></div>
      </div>
      <div class="hamburger-dropdown" id="hamburgerDropdown">
        <a href="/" class="{% if request.path == '/' %}active{% endif %}">사이트 성과</a>
        <a href="{{ url_for('ads_page') }}" class="{% if request.path == '/ads' %}active{% endif %}">광고 성과</a>
        <a href="{{ url_for('trend_selection_page') }}" class="{% if request.path.startswith('/trend') %}active{% endif %}">TREND</a>
        <a href="{{ url_for('auth.logout') }}">로그아웃</a>
      </div>
    </div>
  </div>
</div>

<!-- ✅ Progress Bar -->
<div class="admake-progress-bar">
  <div class="admake-progress-steps">
    <div class="admake-progress-step completed">STEP 1</div>
    <div class="admake-progress-connector completed"></div>
    <div class="admake-progress-step active">STEP 2</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 3</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 4</div>
    <div class="admake-progress-connector"></div>
    <div class="admake-progress-step">STEP 5</div>
  </div>
</div>

<!-- ✅ 메인 컨텐츠 -->
<div class="admake-crop-wrapper">
  <!-- 좌측: 미디어 리스트 -->
  <div class="admake-crop-left">
    <div class="admake-media-list">
      <div class="admake-media-list-title">미디어 목록</div>
      <div id="mediaListContainer"></div>
    </div>
  </div>

  <!-- 중앙: 가이드 컨테이너 -->
  <div class="admake-crop-center">
    <div class="admake-guide-labels-wrapper">
      <!-- 가이드 라벨 외부 배치 (좌측) -->
      <div class="admake-guide-labels-container">
        <div class="admake-guide-label admake-guide-label-9-16">9:16</div>
        <div class="admake-guide-label admake-guide-label-4-5">4:5</div>
        <div class="admake-guide-label admake-guide-label-1-1">1:1</div>
      </div>
      
      <div class="admake-guide-container" id="guideContainer">
        <div class="admake-guide-preview" id="guidePreview">
          <canvas class="admake-crop-canvas" id="cropCanvas" style="display: none;"></canvas>
          <!-- 가이드라인 (비율에 따라 표시/숨김) -->
          <div class="admake-guide-line admake-guide-line-4-5"></div>
          <div class="admake-guide-line admake-guide-line-1-1"></div>
          <div id="placeholderText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #9ca3af; font-size: 14px; text-align: center; z-index: 2; pointer-events: none;">
            미디어를 선택하세요
          </div>
          <div id="videoNotice" class="admake-video-notice" style="display: none;">
            동영상은 9:16 권장 비율입니다
          </div>
        </div>
      </div>
    </div>
    
    <!-- 크롭 컨트롤 (이미지일 때만 표시) -->
    <div class="admake-crop-controls" id="cropControls" style="display: none;">
      <!-- 자르기 비율 버튼 (Toggle Group) -->
      <div class="admake-ratio-buttons">
        <button class="admake-ratio-btn active" id="ratioBtn916" data-ratio="9/16" title="9:16 비율로 자르기">9:16</button>
        <button class="admake-ratio-btn" id="ratioBtn45" data-ratio="4/5" title="4:5 비율로 자르기">4:5</button>
        <button class="admake-ratio-btn" id="ratioBtn11" data-ratio="1/1" title="1:1 비율로 자르기">1:1</button>
      </div>
      <div style="font-size: 11px; color: #6b7280; margin-top: -8px; margin-bottom: 12px; text-align: center;">
        비율을 선택하면 해당 비율로 자동 자르기됩니다
      </div>
      
      <!-- 확대/축소 슬라이더 -->
      <div class="admake-zoom-control">
        <span class="admake-zoom-label">확대/축소</span>
        <input type="range" id="zoomSlider" class="admake-zoom-slider" min="0.01" max="3" step="0.01" value="1">
        <span class="admake-zoom-value" id="zoomValue">100%</span>
      </div>
      
      <!-- 확인 버튼 -->
      <button class="admake-btn admake-btn-primary" id="confirmBtn" style="margin-top: 16px; width: 100%;">
        이 미디어 확인 완료
      </button>
    </div>
  </div>
</div>

<!-- ✅ 하단 액션 바 -->
<div class="admake-action-bar">
  <div></div>
  <div class="admake-action-buttons">
    <button class="admake-btn admake-btn-secondary" id="backBtn">이전</button>
    <button class="admake-btn admake-btn-primary" id="uploadBtn" disabled>
      <span id="uploadBtnText">메타에 업로드 하기</span>
      <span id="uploadBtnCount" style="display: none; margin-left: 8px; font-size: 12px; opacity: 0.8;"></span>
    </button>
  </div>
</div>

<!-- ✅ 로딩 오버레이 -->
<div class="admake-loading-overlay" id="loadingOverlay">
  <div class="admake-loading-content">
    <div class="admake-loading-spinner"></div>
    <div class="admake-loading-text">메타 서버에 소재를 등록 중입니다...</div>
    <div class="admake-progress-bar-container" style="margin-top: 24px; width: 100%; max-width: 400px;">
      <div class="admake-progress-bar-bg" style="width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden;">
        <div class="admake-progress-bar-fill" id="uploadProgressBar" style="height: 100%; background: #111827; width: 0%; transition: width 0.3s ease;"></div>
      </div>
      <div class="admake-progress-text" id="uploadProgressText" style="margin-top: 8px; font-size: 12px; color: #6b7280; text-align: center;">
        0 / 0 업로드 중...
      </div>
    </div>
  </div>
</div>

<script src="{{ url_for('static', filename='js/common.js') }}"></script>
<script src="{{ url_for('static', filename='js/common_ui.js') }}"></script>

<script>
// ✅ 상태 관리 - 개선된 구조
let mediaItems = []; // [{ id, name, type, mediaType, previewUrl, cropState: { x, y, zoom }, isConfirmed }]
let selectedMediaIndex = -1;
let uploadedResults = []; // 업로드 결과 { id, hash/video_id, type }

// ✅ Canvas 관련 변수
let canvas, ctx;
let currentImage = null;
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let currentX = 0;
let currentY = 0;
let currentZoom = 1;
let containerWidth = 0;
let containerHeight = 0;
let currentAspectRatio = 9/16; // 현재 선택된 비율 (9:16, 4:5, 1:1) - 디폴트 9:16
let minZoom = 1; // 최소 확대 배율 (동적 계산)

// ✅ IndexedDB에서 File 객체 가져오기
async function getFileFromIndexedDB(mediaId) {
  return new Promise((resolve, reject) => {
    if (!('indexedDB' in window)) {
      reject(new Error('IndexedDB를 지원하지 않습니다'));
      return;
    }

    const dbName = 'admake_files';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['files'], 'readonly');
      const store = transaction.objectStore('files');
      const getRequest = store.get(mediaId);

      getRequest.onsuccess = () => {
        if (getRequest.result && getRequest.result.file) {
          resolve(getRequest.result.file);
        } else {
          reject(new Error('파일을 찾을 수 없습니다'));
        }
      };

      getRequest.onerror = () => reject(getRequest.error);
    };

    request.onerror = () => reject(request.error);
  });
}

// ✅ Blob URL 유효성 검사 및 복구
async function validateAndRecoverBlobUrl(item) {
  // 기존 previewUrl이 유효한지 확인
  if (item.previewUrl) {
    try {
      const response = await fetch(item.previewUrl, { method: 'HEAD' });
      if (response.ok) {
        console.log(`[DEBUG] 기존 Blob URL 유효: ${item.id}`);
        return item.previewUrl;
      }
    } catch (e) {
      console.warn(`[WARN] 기존 Blob URL 유효하지 않음: ${item.id}`, e);
    }
  }
  
  // IndexedDB에서 File 객체 가져와서 새로운 Blob URL 생성
  try {
    const file = await getFileFromIndexedDB(item.id);
    const newPreviewUrl = URL.createObjectURL(file);
    console.log(`[DEBUG] 미디어 ${item.id} Blob URL 재생성 성공`);
    return newPreviewUrl;
  } catch (e) {
    console.error(`[ERROR] IndexedDB에서 ${item.id} 로드 실패:`, e);
    throw new Error(`미디어 ${item.id} 로드 실패`);
  }
}

// ✅ STEP 2 초기화 함수 (데이터 복구 강화)
async function initStep2() {
  // mediaItems가 비어있으면 IndexedDB에서 복구
  if (mediaItems.length === 0) {
    console.log('[DEBUG] mediaItems가 비어있음 - IndexedDB에서 복구 시도');
    await loadStep1Data();
  }
}

// ✅ STEP 1에서 저장된 데이터 불러오기 (Blob URL 복구)
async function loadStep1Data() {
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (!step1Data) {
    alert('STEP 1 데이터를 찾을 수 없습니다. 처음부터 시작해주세요.');
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    return;
  }

  try {
    const data = JSON.parse(step1Data);
    
    // 각 미디어에 대해 IndexedDB에서 File 객체를 가져와서 새로운 Blob URL 생성
    const loadedItems = await Promise.all(
      data.mediaItems.map(async (item) => {
        let previewUrl = null;
        let file = null;
        
        try {
          // IndexedDB에서 File 객체 가져오기
          file = await getFileFromIndexedDB(item.id);
          // 새로운 Blob URL 생성 (만료된 URL 대체)
          previewUrl = URL.createObjectURL(file);
          console.log(`[DEBUG] 미디어 ${item.id} Blob URL 재생성 성공`);
        } catch (e) {
          console.warn(`[WARN] IndexedDB에서 ${item.id} 로드 실패, 기존 URL 시도:`, e);
          
          // IndexedDB 실패 시 기존 previewUrl이 유효한지 확인
          try {
            const response = await fetch(item.previewUrl, { method: 'HEAD' });
            if (response.ok) {
              previewUrl = item.previewUrl;
              console.log(`[DEBUG] 기존 Blob URL 유효: ${item.id}`);
            } else {
              throw new Error('기존 URL도 유효하지 않음');
            }
          } catch (fetchError) {
            console.error(`[ERROR] 미디어 ${item.id} URL 복구 실패:`, fetchError);
            // URL 복구 실패 시 사용자에게 알림
            alert(`미디어 "${item.name}"을 불러올 수 없습니다. STEP 1로 돌아가서 다시 업로드해주세요.`);
            throw new Error(`미디어 ${item.id} 로드 실패`);
          }
        }
        
        // 저장된 크롭 상태 복원 (있는 경우)
        const savedCropState = item.cropState || { x: 0, y: 0, zoom: 1 };
        const savedIsConfirmed = item.isConfirmed || false;
        
        return {
          id: item.id,
          name: item.name,
          size: item.size,
          type: item.type,
          mediaType: item.mediaType,
          previewUrl: previewUrl,
          file: file, // File 객체 저장 (나중에 업로드 시 사용)
          cropState: savedCropState, // 저장된 크롭 상태 복원
          isConfirmed: savedIsConfirmed // 저장된 확인 상태 복원
        };
      })
    );
    
    mediaItems = loadedItems;
    console.log(`[DEBUG] ${mediaItems.length}개 미디어 로드 완료`);
    
    renderMediaList();
    
    // 첫 번째 미디어 자동 선택 및 즉시 표시
    if (mediaItems.length > 0) {
      console.log('[DEBUG] 첫 번째 미디어 자동 선택');
      // 약간의 지연을 두어 DOM이 완전히 렌더링된 후 선택
      setTimeout(() => {
        selectMedia(0);
      }, 100);
    }
  } catch (e) {
    console.error('STEP 1 데이터 로드 실패:', e);
    alert('데이터를 불러오는 중 오류가 발생했습니다: ' + e.message);
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
}

// ✅ 미디어 리스트 렌더링
function renderMediaList() {
  const container = document.getElementById('mediaListContainer');
  container.innerHTML = '';

  mediaItems.forEach((item, index) => {
    const mediaItem = document.createElement('div');
    mediaItem.className = `admake-media-item ${selectedMediaIndex === index ? 'selected' : ''}`;
    mediaItem.setAttribute('data-index', index);
    
    let mediaElement = '';
    if (item.mediaType === 'video') {
      mediaElement = `<video src="${item.previewUrl}" class="admake-media-item-video" muted playsinline loop></video>`;
    } else {
      mediaElement = `<img src="${item.previewUrl}" class="admake-media-item-image" alt="${item.name}">`;
    }

    const checkedIcon = item.isConfirmed ? '✓' : '';
    const confirmedClass = item.isConfirmed ? 'confirmed' : '';
    
    mediaItem.innerHTML = `
      ${mediaElement}
      <div class="admake-media-item-badge">${item.mediaType === 'video' ? 'VIDEO' : 'IMAGE'}</div>
      <div class="admake-media-item-checked ${confirmedClass}">${checkedIcon}</div>
    `;

    mediaItem.addEventListener('click', async () => {
      // 클릭 시 Blob URL 유효성 검사
      const clickedItem = mediaItems[index];
      if (clickedItem.mediaType === 'image') {
        try {
          // 미리 유효성 검사
          await validateAndRecoverBlobUrl(clickedItem).then(recoveredUrl => {
            if (recoveredUrl !== clickedItem.previewUrl) {
              clickedItem.previewUrl = recoveredUrl;
              // 리스트의 이미지도 업데이트
              const imgElement = mediaItem.querySelector('img');
              if (imgElement) {
                imgElement.src = recoveredUrl;
              }
            }
          });
        } catch (e) {
          console.error(`[ERROR] 미디어 ${clickedItem.id} URL 검증 실패:`, e);
          alert(`이미지 "${clickedItem.name}"을 불러올 수 없습니다.`);
          return;
        }
      }
      selectMedia(index);
    });

    container.appendChild(mediaItem);
  });
}

// ✅ Canvas 초기화
function initCanvas() {
  canvas = document.getElementById('cropCanvas');
  if (!canvas) return;

  ctx = canvas.getContext('2d');
  updateCanvasSize();

  // 리사이즈 이벤트 처리 (디바운스 적용)
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      const prevContainerWidth = containerWidth;
      const prevContainerHeight = containerHeight;

      updateCanvasSize();

      if (currentImage && containerWidth > 0 && containerHeight > 0) {
        // ===== [핵심] 리사이즈 시 minZoom 재계산 =====
        // 컨테이너 크기가 변경되었으면 minZoom을 다시 계산
        if (prevContainerWidth !== containerWidth || prevContainerHeight !== containerHeight) {
          const newMinZoom = calculateInitialZoom(currentImage, containerWidth, containerHeight, currentAspectRatio);
          console.log(`[RESIZE] minZoom 재계산: ${minZoom.toFixed(6)} (컨테이너: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)})`);

          // 현재 zoom이 새로운 minZoom보다 작으면 조정
          if (currentZoom < minZoom) {
            currentZoom = minZoom;
            // 슬라이더 업데이트
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomValue = document.getElementById('zoomValue');
            if (zoomSlider) {
              const maxZoom = Math.max(minZoom * 3, 1);
              zoomSlider.min = minZoom;
              zoomSlider.max = maxZoom;
              zoomSlider.value = currentZoom;
            }
            if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
          }
        }
        drawImage();
      }
    }, 100); // 100ms 디바운스
  });
  
  // 드래그 이벤트
  canvas.addEventListener('mousedown', startDrag);
  canvas.addEventListener('mousemove', onDrag);
  canvas.addEventListener('mouseup', endDrag);
  canvas.addEventListener('mouseleave', endDrag);
  
  // 터치 이벤트 (모바일)
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    startDrag({
      clientX: touch.clientX,
      clientY: touch.clientY,
      target: canvas
    });
  });
  
  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    onDrag({
      clientX: touch.clientX,
      clientY: touch.clientY
    });
  });
  
  canvas.addEventListener('touchend', endDrag);
}

// ✅ Canvas 크기 업데이트 (반응형 컨테이너 대응)
function updateCanvasSize() {
  const container = document.getElementById('guideContainer');
  if (!container) return false;

  // getBoundingClientRect()로 실제 렌더링된 크기 가져오기 (clientWidth보다 정확)
  const rect = container.getBoundingClientRect();
  containerWidth = rect.width;
  containerHeight = rect.height;

  // 컨테이너 크기가 유효하지 않으면 false 반환
  if (containerWidth <= 0 || containerHeight <= 0) {
    console.warn(`[WARN] 컨테이너 크기 무효: ${containerWidth}x${containerHeight}`);
    return false;
  }

  if (canvas) {
    canvas.width = containerWidth;
    canvas.height = containerHeight;
  }

  console.log(`[DEBUG] 컨테이너 크기 업데이트: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);
  return true;
}

// ✅ 드래그 시작
function startDrag(e) {
  if (!currentImage) return;
  isDragging = true;
  const rect = canvas.getBoundingClientRect();
  dragStartX = e.clientX - rect.left;
  dragStartY = e.clientY - rect.top;
  canvas.style.cursor = 'grabbing';
}

// ✅ 드래그 중
function onDrag(e) {
  if (!isDragging || !currentImage) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const deltaX = x - dragStartX;
  const deltaY = y - dragStartY;
  
  currentX += deltaX;
  currentY += deltaY;
  
  dragStartX = x;
  dragStartY = y;
  
  drawImage();
}

// ✅ 드래그 종료 (상태 저장 + IndexedDB 동기화)
function endDrag() {
  if (isDragging) {
    isDragging = false;
    canvas.style.cursor = 'move';
    saveCropState();

    // IndexedDB 상태 동기화 (드래그 완료 시점에 저장)
    syncCropStateToIndexedDB();
  }
}

// ✅ 이미지 그리기 (restrictPosition: true 효과 - 여백 원천 차단)
function drawImage() {
  if (!currentImage || !ctx) return;

  // ===== [핵심] naturalWidth/naturalHeight 명시적 사용 =====
  const imageNaturalWidth = currentImage.naturalWidth || currentImage.width;
  const imageNaturalHeight = currentImage.naturalHeight || currentImage.height;

  if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
    console.error('[ERROR] drawImage: 이미지 원본 크기 무효');
    return;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 선택된 비율에 맞는 크롭 영역 계산
  const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
  const cropX = (containerWidth - cropArea.width) / 2;
  const cropY = (containerHeight - cropArea.height) / 2;

  // ===== restrictPosition: true 효과 - 줌 강제 보정 =====
  // 현재 줌이 minZoom보다 작으면 강제로 minZoom으로 조정 (여백 원천 차단)
  if (currentZoom < minZoom) {
    console.log(`[RESTRICT] 줌 강제 보정: ${currentZoom.toFixed(6)} → ${minZoom.toFixed(6)}`);
    currentZoom = minZoom;
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomSlider) zoomSlider.value = currentZoom;
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';
  }

  const imgWidth = imageNaturalWidth * currentZoom;
  const imgHeight = imageNaturalHeight * currentZoom;

  // ===== restrictPosition: true 효과 - 엄격한 경계 제한 =====
  // 이미지 경계가 프레임 안으로 들어오는 것을 절대 허용하지 않음
  // 1. 이미지 좌상단이 프레임 좌상단보다 우측/하단에 있으면 안됨 (좌측/상단 여백 방지)
  // 2. 이미지 우하단이 프레임 우하단보다 좌측/상단에 있으면 안됨 (우측/하단 여백 방지)

  // currentX, currentY를 크롭 영역 기준으로 조정
  let relativeX = currentX - cropX;
  let relativeY = currentY - cropY;

  // 경계 계산 (이미지가 프레임보다 클 때만 이동 가능)
  // 좌측/상단 경계: relativeX/Y <= 0
  // 우측/하단 경계: relativeX/Y >= -(imgWidth - cropArea.width)
  const minRelativeX = Math.min(0, -(imgWidth - cropArea.width));
  const minRelativeY = Math.min(0, -(imgHeight - cropArea.height));

  // 엄격한 경계 적용 (clamp)
  const finalX = Math.max(minRelativeX, Math.min(0, relativeX));
  const finalY = Math.max(minRelativeY, Math.min(0, relativeY));

  // 이미지를 크롭 영역에 맞춰 그리기 (clip 사용 - 프레임 밖 잘라내기)
  ctx.save();
  ctx.beginPath();
  ctx.rect(cropX, cropY, cropArea.width, cropArea.height);
  ctx.clip();

  ctx.drawImage(
    currentImage,
    cropX + finalX,
    cropY + finalY,
    imgWidth,
    imgHeight
  );

  ctx.restore();

  // currentX, currentY 업데이트 (절대 좌표로 저장)
  currentX = cropX + finalX;
  currentY = cropY + finalY;
}

// ✅ 크롭 상태 저장 (메모리 + sessionStorage)
function saveCropState() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];
    item.cropState = {
      x: currentX,
      y: currentY,
      zoom: currentZoom,
      aspectRatio: currentAspectRatio, // 비율도 저장
      minZoom: minZoom // minZoom도 저장 (복원 시 비교용)
    };
    // 상태 저장 시 자동으로 확인 처리하지 않음 (사용자가 명시적으로 확인해야 함)

    console.log(`[SAVE] 크롭 상태 저장: zoom=${currentZoom.toFixed(4)}, minZoom=${minZoom.toFixed(4)}, ratio=${currentAspectRatio}`);

    // sessionStorage에도 상태 저장 (페이지 새로고침 대비)
    const step1Data = sessionStorage.getItem('admake_step1_state');
    if (step1Data) {
      try {
        const data = JSON.parse(step1Data);
        const mediaItemIdx = data.mediaItems.findIndex(m => m.id === item.id);
        if (mediaItemIdx >= 0) {
          data.mediaItems[mediaItemIdx].cropState = item.cropState;
          data.mediaItems[mediaItemIdx].isConfirmed = item.isConfirmed;
          sessionStorage.setItem('admake_step1_state', JSON.stringify(data));
        }
      } catch (e) {
        console.warn('[SYNC] sessionStorage 동기화 실패:', e);
      }
    }
  }
}

// ✅ IndexedDB 상태 동기화 (비동기 - 끊김 방지)
async function syncCropStateToIndexedDB() {
  if (!('indexedDB' in window) || mediaItems.length === 0) return;

  try {
    const dbName = 'admake_files';
    const request = indexedDB.open(dbName, 1);

    request.onsuccess = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('files')) return;

      const transaction = db.transaction(['files'], 'readwrite');
      const store = transaction.objectStore('files');

      mediaItems.forEach(item => {
        if (item.file) {
          store.put({
            id: item.id,
            file: item.file,
            previewUrl: item.previewUrl,
            type: item.type,
            mediaType: item.mediaType,
            cropState: item.cropState,
            isConfirmed: item.isConfirmed
          });
        }
      });

      transaction.oncomplete = () => {
        console.log('[SYNC] IndexedDB 상태 동기화 완료');
      };
    };

    request.onerror = (e) => {
      console.warn('[SYNC] IndexedDB 열기 실패:', e);
    };
  } catch (e) {
    console.warn('[SYNC] IndexedDB 동기화 오류:', e);
  }
}

// ✅ 선택된 비율에 맞는 크롭 영역 크기 계산
function getCropAreaSize(containerWidth, containerHeight, aspectRatio) {
  let cropWidth, cropHeight;
  
  if (aspectRatio === 9/16) {
    // 9:16 - 전체 컨테이너 사용
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  } else if (aspectRatio === 4/5) {
    // 4:5 - 컨테이너 너비에 맞춤
    cropWidth = containerWidth;
    cropHeight = containerWidth / (4/5);
    if (cropHeight > containerHeight) {
      cropHeight = containerHeight;
      cropWidth = containerHeight * (4/5);
    }
  } else if (aspectRatio === 1/1) {
    // 1:1 - 정사각형
    const size = Math.min(containerWidth, containerHeight);
    cropWidth = size;
    cropHeight = size;
  } else {
    cropWidth = containerWidth;
    cropHeight = containerHeight;
  }
  
  return { width: cropWidth, height: cropHeight };
}

// ✅ 고화질 이미지 대응: Cover Fit 최소 배율 계산 (여백 없이 프레임 꽉 채움)
function calculateInitialZoom(img, containerWidth, containerHeight, aspectRatio) {
  // ===== [핵심] naturalWidth/naturalHeight 명시적 사용 =====
  // Image 객체에서 width/height는 로드 후 naturalWidth/naturalHeight와 동일하지만
  // 명시적으로 사용하여 의도를 명확히 함
  const imageNaturalWidth = img.naturalWidth || img.width;
  const imageNaturalHeight = img.naturalHeight || img.height;

  // 이미지 크기가 유효하지 않으면 기본값 반환
  if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
    console.error(`[ERROR] 이미지 원본 크기 무효: ${imageNaturalWidth}x${imageNaturalHeight}`);
    minZoom = 1;
    return 1;
  }

  const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);

  // 크롭 영역 크기가 유효하지 않으면 기본값 반환
  if (cropArea.width <= 0 || cropArea.height <= 0) {
    console.error(`[ERROR] 크롭 영역 크기 무효: ${cropArea.width}x${cropArea.height}`);
    minZoom = 1;
    return 1;
  }

  // ===== Cover Fit 계산 (핵심 로직) =====
  // 이미지 해상도에 관계없이 프레임을 여백 없이 꽉 채우는 최소 배율
  // 공식: minZoom = Math.max(frameWidth / imageWidth, frameHeight / imageHeight)
  const coverZoom = Math.max(
    cropArea.width / imageNaturalWidth,
    cropArea.height / imageNaturalHeight
  );

  // 최소 확대 비율 = Cover Fit 배율 (여백 원천 차단)
  // 이 값 이하로는 절대 축소 불가능 (restrictPosition: true 효과)
  // 고화질 이미지의 경우 minZoom이 매우 작을 수 있으므로 최소 0.001 보장
  minZoom = Math.max(0.001, coverZoom);

  console.log(`[MASTER FIX] Cover Fit 계산: 원본(${imageNaturalWidth}x${imageNaturalHeight}), 프레임(${cropArea.width.toFixed(0)}x${cropArea.height.toFixed(0)}), minZoom=${minZoom.toFixed(6)}`);

  // minZoom 값을 반환 (초기 배율로 사용)
  return minZoom;
}

// ✅ 크롭 상태 불러오기 (초기 화면 최적화: 9:16 디폴트, 여백 없이)
function loadCropState(item, img = null) {
  // 디폴트 비율을 9:16으로 설정 (초기 화면 최적화)
  if (!item.cropState || !item.cropState.aspectRatio) {
    currentAspectRatio = 9/16;
  } else {
    // 저장된 비율 복원
    currentAspectRatio = item.cropState.aspectRatio;
  }

  // ===== [핵심] 이미지 원본 크기 캡처 =====
  const imageNaturalWidth = img ? (img.naturalWidth || img.width) : 0;
  const imageNaturalHeight = img ? (img.naturalHeight || img.height) : 0;

  // ===== [핵심] 이미지가 있으면 무조건 minZoom 먼저 계산 =====
  // 이렇게 해야 저장된 상태 복원 시에도 올바른 minZoom이 적용됨
  if (img && containerWidth > 0 && containerHeight > 0 && imageNaturalWidth > 0 && imageNaturalHeight > 0) {
    // Cover Fit 최소 배율 계산 (여백 원천 차단)
    calculateInitialZoom(img, containerWidth, containerHeight, currentAspectRatio);
    console.log(`[MASTER FIX] minZoom 계산 완료: ${minZoom.toFixed(6)} (원본: ${imageNaturalWidth}x${imageNaturalHeight})`);
  }

  if (item && item.cropState && item.cropState.zoom > 0) {
    // 저장된 크롭 상태가 있으면 사용
    currentX = item.cropState.x;
    currentY = item.cropState.y;
    currentZoom = item.cropState.zoom;

    // ===== [핵심] 저장된 zoom이 minZoom보다 작으면 강제로 minZoom으로 조정 =====
    // 고화질 이미지의 경우 이전에 저장된 zoom 값이 현재 계산된 minZoom보다 작을 수 있음
    if (img && currentZoom < minZoom) {
      console.log(`[MASTER FIX] 저장된 zoom(${currentZoom.toFixed(6)})이 minZoom(${minZoom.toFixed(6)})보다 작음 → minZoom으로 강제 조정`);
      currentZoom = minZoom;

      // 위치도 중앙으로 재조정
      const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;
      const imgWidth = imageNaturalWidth * currentZoom;
      const imgHeight = imageNaturalHeight * currentZoom;
      currentX = cropX + (cropArea.width - imgWidth) / 2;
      currentY = cropY + (cropArea.height - imgHeight) / 2;
    }

    // 비율 버튼 상태 업데이트
    updateRatioButtons();
  } else {
    // 초기 상태 - 이미지가 선택된 비율 박스에 여백 없이 꽉 차게 자동 계산
    if (img && containerWidth > 0 && containerHeight > 0 && imageNaturalWidth > 0 && imageNaturalHeight > 0) {
      // 크롭 영역 계산
      const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;

      // 초기 배율 = Cover Fit 배율 (minZoom)으로 시작
      currentZoom = minZoom;

      // 이미지를 크롭 영역 중앙에 배치
      const imgWidth = imageNaturalWidth * currentZoom;
      const imgHeight = imageNaturalHeight * currentZoom;
      currentX = cropX + (cropArea.width - imgWidth) / 2;
      currentY = cropY + (cropArea.height - imgHeight) / 2;

      console.log(`[MASTER FIX] 초기 배율 자동 설정: ${currentZoom.toFixed(6)} (Cover Fit, 원본 ${imageNaturalWidth}x${imageNaturalHeight})`);
    } else {
      currentX = 0;
      currentY = 0;
      currentZoom = 1;
      console.warn(`[WARN] 초기화 폴백: 컨테이너(${containerWidth}x${containerHeight}), 이미지(${imageNaturalWidth}x${imageNaturalHeight})`);
    }
  }

  // UI 업데이트 (슬라이더 범위 동적 설정: min=minZoom, max=minZoom*3)
  const zoomSlider = document.getElementById('zoomSlider');
  const zoomValue = document.getElementById('zoomValue');
  if (zoomSlider) {
    if (img && containerWidth > 0 && containerHeight > 0 && minZoom > 0) {
      // ===== 슬라이더 범위 동적 설정 =====
      // min: Cover Fit 배율 (이 이하로 축소 불가 - 여백 원천 차단)
      // max: minZoom * 3 (고화질 이미지에서도 부드러운 확대/축소)
      const maxZoom = Math.max(minZoom * 3, 1); // 최소 1 보장
      zoomSlider.min = minZoom;
      zoomSlider.max = maxZoom;
      zoomSlider.step = Math.max((maxZoom - minZoom) / 100, 0.0001); // 100단계로 분할, 최소 0.0001

      console.log(`[MASTER FIX] 슬라이더 범위 설정: min=${minZoom.toFixed(6)}, max=${maxZoom.toFixed(4)}, step=${zoomSlider.step}`);
    }
    zoomSlider.value = currentZoom;
  }
  if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

  // 비율 버튼 상태 업데이트
  updateRatioButtons();
}

// ✅ 비율 버튼 상태 업데이트
function updateRatioButtons() {
  const buttons = document.querySelectorAll('.admake-ratio-btn');
  buttons.forEach(btn => {
    const ratioStr = btn.getAttribute('data-ratio');
    const ratioValue = eval(ratioStr); // "9/16" -> 0.5625, "4/5" -> 0.8, "1/1" -> 1
    if (Math.abs(currentAspectRatio - ratioValue) < 0.001) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

// ✅ 가이드라인 표시/숨김 업데이트
function updateGuideLines() {
  const guide45 = document.querySelector('.admake-guide-line-4-5');
  const guide11 = document.querySelector('.admake-guide-line-1-1');
  
  if (guide45 && guide11) {
    // 선택된 비율에 따라 가이드라인 표시
    if (currentAspectRatio === 4/5) {
      guide45.classList.remove('hidden');
      guide11.classList.add('hidden');
    } else if (currentAspectRatio === 1/1) {
      guide45.classList.add('hidden');
      guide11.classList.remove('hidden');
    } else {
      // 9:16일 때는 둘 다 표시
      guide45.classList.remove('hidden');
      guide11.classList.remove('hidden');
    }
  }
}

// ✅ 비율 변경 처리 (실제 자르기 연동)
function changeAspectRatio(ratio) {
  currentAspectRatio = ratio;
  updateRatioButtons();
  updateGuideLines(); // 가이드라인 업데이트

  console.log(`[DEBUG] 비율 변경: ${ratio} (${ratio === 9/16 ? '9:16' : ratio === 4/5 ? '4:5' : '1:1'})`);

  if (currentImage && containerWidth > 0 && containerHeight > 0) {
    // ===== [핵심] naturalWidth/naturalHeight 명시적 사용 =====
    const imageNaturalWidth = currentImage.naturalWidth || currentImage.width;
    const imageNaturalHeight = currentImage.naturalHeight || currentImage.height;

    if (imageNaturalWidth <= 0 || imageNaturalHeight <= 0) {
      console.error('[ERROR] changeAspectRatio: 이미지 원본 크기 무효');
      return;
    }

    // 새로운 비율에 맞는 크롭 영역 계산
    const cropArea = getCropAreaSize(containerWidth, containerHeight, currentAspectRatio);
    const cropX = (containerWidth - cropArea.width) / 2;
    const cropY = (containerHeight - cropArea.height) / 2;

    // 새로운 비율에 맞게 최소 배율 재계산
    calculateInitialZoom(currentImage, containerWidth, containerHeight, currentAspectRatio);

    // 현재 배율이 최소값보다 작으면 최소값으로 조정
    if (currentZoom < minZoom) {
      currentZoom = minZoom;
    }

    // 이미지 위치를 새로운 크롭 영역 중앙으로 조정
    const imgWidth = imageNaturalWidth * currentZoom;
    const imgHeight = imageNaturalHeight * currentZoom;

    // 이미지를 크롭 영역 중앙에 배치
    currentX = cropX + (cropArea.width - imgWidth) / 2;
    currentY = cropY + (cropArea.height - imgHeight) / 2;

    // 슬라이더 업데이트 (동적 범위: min=minZoom, max=minZoom*3)
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    if (zoomSlider) {
      const maxZoom = Math.max(minZoom * 3, 1);
      zoomSlider.min = minZoom;
      zoomSlider.max = maxZoom;
      zoomSlider.step = Math.max((maxZoom - minZoom) / 100, 0.0001);
      zoomSlider.value = currentZoom;
    }
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

    // 이미지 다시 그리기
    drawImage();

    // 크롭 상태 저장
    saveCropState();

    // IndexedDB 상태 동기화
    syncCropStateToIndexedDB();
  }
}

// ✅ 미디어 확인 처리 (토글 기능 - 확인/수정하기)
function confirmMedia() {
  if (selectedMediaIndex >= 0 && selectedMediaIndex < mediaItems.length) {
    const item = mediaItems[selectedMediaIndex];

    // 토글: 확인 → 수정 또는 수정 → 확인
    item.isConfirmed = !item.isConfirmed;
    saveCropState(); // 현재 크롭 상태 저장

    // 확인 버튼 상태 업데이트 (토글 기능)
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      if (item.isConfirmed) {
        // 확인됨 → "수정하기" 버튼으로 변경 (다시 클릭하면 수정 가능)
        confirmBtn.textContent = '수정하기';
        confirmBtn.classList.add('confirmed');
        confirmBtn.style.background = '#059669'; // 녹색
        console.log(`[CONFIRM] 미디어 ${item.id} 확인 완료 (수정하기 클릭 시 취소 가능)`);
      } else {
        // 수정 모드 → "이 미디어 확인 완료" 버튼으로 변경
        confirmBtn.textContent = '이 미디어 확인 완료';
        confirmBtn.classList.remove('confirmed');
        confirmBtn.style.background = '#111827'; // 기본 검정색
        console.log(`[CONFIRM] 미디어 ${item.id} 수정 모드로 전환`);
      }
    }

    renderMediaList();
    updateUploadButtonState();

    // IndexedDB 상태 동기화 (상태 유지 강화)
    syncCropStateToIndexedDB();
  }
}

// ✅ 미디어 선택
async function selectMedia(index) {
  selectedMediaIndex = index;
  const item = mediaItems[index];
  
  // 가이드 프리뷰 업데이트
  const preview = document.getElementById('guidePreview');
  const placeholder = document.getElementById('placeholderText');
  const videoNotice = document.getElementById('videoNotice');
  const cropControls = document.getElementById('cropControls');
  
  // 기존 미디어 제거
  let existingMedia = preview.querySelector('.admake-guide-preview-image, .admake-guide-preview-video');
  if (existingMedia) existingMedia.remove();
  
  // Canvas 초기화
  if (canvas) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  
  if (item.mediaType === 'video') {
    // 동영상은 크롭 불가, 미리보기만
    videoNotice.style.display = 'block';
    cropControls.style.display = 'none';
    canvas.style.display = 'none';
    
    // 확인 버튼 숨기기
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'none';
    }
    
    // 동영상은 자동으로 확인 처리 (크롭 불가능하므로)
    if (!item.isConfirmed) {
      item.isConfirmed = true;
      renderMediaList();
      updateUploadButtonState();
    }
    
    const videoElement = document.createElement('video');
    videoElement.className = 'admake-guide-preview-video';
    videoElement.src = item.previewUrl;
    videoElement.muted = true;
    videoElement.playsInline = true;
    videoElement.loop = true;
    videoElement.autoplay = true;
    videoElement.style.position = 'absolute';
    videoElement.style.top = '0';
    videoElement.style.left = '0';
    videoElement.style.width = '100%';
    videoElement.style.height = '100%';
    videoElement.style.objectFit = 'contain';
    videoElement.style.zIndex = '1';
    
    preview.appendChild(videoElement);
    currentImage = null;
  } else {
    // 이미지는 크롭 가능
    videoNotice.style.display = 'none';
    cropControls.style.display = 'block';
    
    // Canvas 표시
    canvas.style.display = 'block';
    
    // 확인 버튼 표시 및 상태 업데이트 (토글 버튼)
    const confirmBtn = document.getElementById('confirmBtn');
    if (confirmBtn) {
      confirmBtn.style.display = 'block';
      // 토글 버튼이므로 항상 활성화 상태
      confirmBtn.disabled = false;
      if (item.isConfirmed) {
        // 확인됨 → "수정하기" 버튼 표시
        confirmBtn.textContent = '수정하기';
        confirmBtn.classList.add('confirmed');
        confirmBtn.style.background = '#059669'; // 녹색
      } else {
        // 미확인 → "이 미디어 확인 완료" 버튼 표시
        confirmBtn.textContent = '이 미디어 확인 완료';
        confirmBtn.classList.remove('confirmed');
        confirmBtn.style.background = '#111827'; // 기본 검정색
      }
    }
    
    // 이미지 로드 (Blob URL 유효성 검사 포함)
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      currentImage = img;

      // ===== [핵심] 컨테이너 준비 대기 로직 =====
      // 반응형 컨테이너가 완전히 렌더링될 때까지 대기
      const waitForContainer = (retryCount = 0) => {
        const containerReady = updateCanvasSize();

        if (!containerReady && retryCount < 10) {
          // 컨테이너가 아직 준비되지 않았으면 50ms 후 재시도 (최대 10회)
          console.log(`[WAIT] 컨테이너 준비 대기 중... (${retryCount + 1}/10)`);
          setTimeout(() => waitForContainer(retryCount + 1), 50);
          return;
        }

        if (!containerReady) {
          console.error('[ERROR] 컨테이너 크기를 가져올 수 없습니다.');
          return;
        }

        // naturalWidth/naturalHeight 로깅
        console.log(`[IMAGE LOADED] 원본 크기: ${img.naturalWidth}x${img.naturalHeight}, 컨테이너: ${containerWidth.toFixed(0)}x${containerHeight.toFixed(0)}`);

        // 크롭 상태 로드 (minZoom 계산 포함)
        loadCropState(item, img);
        // 비율 버튼 상태 업데이트
        updateRatioButtons();
        // 가이드라인 표시 업데이트
        updateGuideLines();
        drawImage();
      };

      // 컨테이너 준비 대기 시작
      waitForContainer();
    };
    img.onerror = async () => {
      console.warn(`[WARN] 이미지 로드 실패, Blob URL 복구 시도: ${item.id}`);
      // Blob URL 복구 시도
      try {
        const recoveredUrl = await validateAndRecoverBlobUrl(item);
        item.previewUrl = recoveredUrl;
        // File 객체도 업데이트
        if (!item.file) {
          item.file = await getFileFromIndexedDB(item.id);
        }
        // 다시 로드 시도
        img.src = recoveredUrl;
      } catch (e) {
        console.error(`[ERROR] 이미지 복구 실패: ${item.id}`, e);
        alert(`이미지 "${item.name}"을 불러올 수 없습니다. STEP 1로 돌아가서 다시 업로드해주세요.`);
        canvas.style.display = 'none';
      }
    };
    img.src = item.previewUrl;
  }
  
  renderMediaList();
}

// ✅ 업로드 버튼 상태 업데이트
function updateUploadButtonState() {
  const uploadBtn = document.getElementById('uploadBtn');
  const uploadBtnText = document.getElementById('uploadBtnText');
  const uploadBtnCount = document.getElementById('uploadBtnCount');
  
  if (!uploadBtn) return;
  
  const confirmedCount = mediaItems.filter(item => item.isConfirmed).length;
  const totalCount = mediaItems.length;
  const allConfirmed = totalCount > 0 && confirmedCount === totalCount;
  const remainingCount = totalCount - confirmedCount;
  
  uploadBtn.disabled = !allConfirmed;
  
  // 버튼 텍스트 및 미완료 개수 표시
  if (uploadBtnText) {
    if (allConfirmed) {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) uploadBtnCount.style.display = 'none';
    } else {
      uploadBtnText.textContent = '메타에 업로드 하기';
      if (uploadBtnCount) {
        uploadBtnCount.textContent = `${remainingCount}개 더 확인 필요`;
        uploadBtnCount.style.display = 'inline';
      }
    }
  }
}

// ✅ 이전 버튼 (Step 1로 돌아가기 - 데이터 유지 및 IndexedDB 복구)
document.getElementById('backBtn').addEventListener('click', async () => {
  // Step 1 상태를 sessionStorage에 다시 저장 (크롭 상태 포함)
  const step1Data = sessionStorage.getItem('admake_step1_state');
  if (step1Data) {
    const data = JSON.parse(step1Data);
    // 크롭 상태 업데이트
    data.mediaItems = data.mediaItems.map(item => {
      const mediaItem = mediaItems.find(m => m.id === item.id);
      if (mediaItem) {
        return {
          ...item,
          cropState: mediaItem.cropState,
          isConfirmed: mediaItem.isConfirmed,
          previewUrl: mediaItem.previewUrl // 최신 Blob URL 저장
        };
      }
      return item;
    });
    sessionStorage.setItem('admake_step1_state', JSON.stringify(data));
    console.log('[DEBUG] Step 1로 돌아가기 - 상태 저장 완료');
  }
  
  // IndexedDB에 최신 상태 저장 (Step 1 복구용)
  if ('indexedDB' in window && mediaItems.length > 0) {
    try {
      const dbName = 'admake_files';
      const request = indexedDB.open(dbName, 1);
      request.onsuccess = (event) => {
        const db = event.target.result;
        if (db.objectStoreNames.contains('files')) {
          const transaction = db.transaction(['files'], 'readwrite');
          const store = transaction.objectStore('files');
          
          mediaItems.forEach(item => {
            if (item.file) {
              store.put({
                id: item.id,
                file: item.file,
                previewUrl: item.previewUrl,
                type: item.type,
                mediaType: item.mediaType,
                cropState: item.cropState,
                isConfirmed: item.isConfirmed
              });
            }
          });
          
          transaction.oncomplete = () => {
            console.log('[DEBUG] IndexedDB 업데이트 완료 - Step 1 복구 준비');
            // Blob URL은 revoke하지 않고 Step 1로 이동
            window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
          };
        } else {
          window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
        }
      };
      request.onerror = () => {
        window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
      };
    } catch (e) {
      console.error('[ERROR] IndexedDB 업데이트 실패:', e);
      window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
    }
  } else {
    // Blob URL은 revoke하지 않고 Step 1로 이동
    window.location.href = `/admake/create?account_id=${encodeURIComponent(accountId)}`;
  }
});

// ✅ 업로드 버튼
document.getElementById('uploadBtn').addEventListener('click', uploadToMeta);

// ✅ 줌 슬라이더 이벤트 (restrictPosition 효과 - minZoom 엄격 적용)
const zoomSlider = document.getElementById('zoomSlider');
if (zoomSlider) {
  zoomSlider.addEventListener('input', (e) => {
    let newZoom = parseFloat(e.target.value);

    // restrictPosition: true 효과 - minZoom 이하로 축소 불가
    if (newZoom < minZoom) {
      console.log(`[RESTRICT] 슬라이더 줌 강제 보정: ${newZoom.toFixed(4)} → ${minZoom.toFixed(4)}`);
      newZoom = minZoom;
      e.target.value = minZoom;
    }

    currentZoom = newZoom;
    const zoomValue = document.getElementById('zoomValue');
    if (zoomValue) zoomValue.textContent = Math.round(currentZoom * 100) + '%';

    if (currentImage) {
      drawImage();
      saveCropState();

      // IndexedDB 상태 동기화 (상태 유지 강화)
      syncCropStateToIndexedDB();
    }
  });
}

// ✅ 확인 버튼 이벤트
const confirmBtn = document.getElementById('confirmBtn');
if (confirmBtn) {
  confirmBtn.addEventListener('click', () => {
    confirmMedia();
  });
}

// ✅ 크롭된 이미지 생성 (Blob)
async function createCroppedImage(mediaItem) {
  return new Promise((resolve, reject) => {
    if (mediaItem.mediaType === 'video') {
      // 동영상은 원본 파일 사용
      getFileFromIndexedDB(mediaItem.id)
        .then(file => resolve(file))
        .catch(() => {
          // IndexedDB 실패 시 previewUrl에서 가져오기
          fetch(mediaItem.previewUrl)
            .then(res => res.blob())
            .then(blob => {
              const file = new File([blob], mediaItem.name, { type: mediaItem.type });
              resolve(file);
            })
            .catch(reject);
        });
      return;
    }
    
    // 이미지는 크롭된 버전 생성 (선택된 비율에 맞게)
    const state = mediaItem.cropState || { x: 0, y: 0, zoom: 1, aspectRatio: 9/16 };
    const aspectRatio = state.aspectRatio || 9/16;

    // 이미지 로드
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      // ===== [핵심] naturalWidth/naturalHeight 명시적 사용 =====
      const imageNaturalWidth = img.naturalWidth || img.width;
      const imageNaturalHeight = img.naturalHeight || img.height;

      // 선택된 비율에 맞는 크롭 영역 계산
      const cropArea = getCropAreaSize(containerWidth, containerHeight, aspectRatio);
      const cropX = (containerWidth - cropArea.width) / 2;
      const cropY = (containerHeight - cropArea.height) / 2;

      // 크롭 캔버스 생성 (선택된 비율 크기)
      const cropCanvas = document.createElement('canvas');
      cropCanvas.width = cropArea.width;
      cropCanvas.height = cropArea.height;
      const cropCtx = cropCanvas.getContext('2d');

      const imgWidth = imageNaturalWidth * state.zoom;
      const imgHeight = imageNaturalHeight * state.zoom;

      // 크롭 영역 기준으로 이미지 위치 계산
      const relativeX = state.x - cropX;
      const relativeY = state.y - cropY;

      cropCtx.drawImage(
        img,
        relativeX,
        relativeY,
        imgWidth,
        imgHeight
      );

      // Canvas를 Blob으로 변환
      cropCanvas.toBlob((blob) => {
        if (!blob) {
          reject(new Error('이미지 생성 실패'));
          return;
        }

        const file = new File([blob], mediaItem.name, { type: 'image/jpeg' });
        resolve(file);
      }, 'image/jpeg', 0.95);
    };
    
    img.onerror = () => {
      reject(new Error('이미지를 불러올 수 없습니다'));
    };
    
    img.src = mediaItem.previewUrl;
  });
}

// ✅ 프로그레스 바 업데이트
function updateUploadProgress(current, total, fileName) {
  const progressBar = document.getElementById('uploadProgressBar');
  const progressText = document.getElementById('uploadProgressText');
  
  const percentage = Math.round((current / total) * 100);
  
  if (progressBar) {
    progressBar.style.width = percentage + '%';
  }
  
  if (progressText) {
    progressText.textContent = `${current} / ${total} 업로드 중... ${fileName ? `(${fileName})` : ''}`;
  }
}

// ✅ 메타 API 업로드 (크롭된 이미지 사용, 순차 처리 및 프로그레스 바)
async function uploadToMeta() {
  const uploadBtn = document.getElementById('uploadBtn');
  const loadingOverlay = document.getElementById('loadingOverlay');
  
  uploadBtn.disabled = true;
  loadingOverlay.classList.add('active');

  try {
    // 서버에서 액세스 토큰 가져오기
    const tokenResponse = await fetch('/dashboard/get_meta_token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ account_id: accountId })
    });
    
    const tokenData = await tokenResponse.json();
    if (tokenData.status !== 'success' || !tokenData.access_token) {
      throw new Error('Meta 액세스 토큰을 가져올 수 없습니다');
    }
    
    const accessToken = tokenData.access_token;
    const apiVersion = 'v24.0';
    const adAccountId = `act_${accountId}`;
    
    uploadedResults = [];
    const errors = [];
    const totalCount = mediaItems.length;
    
    // 각 미디어 파일을 순차적으로 Meta API로 업로드
    for (let i = 0; i < mediaItems.length; i++) {
      const item = mediaItems[i];
      
      try {
        // 프로그레스 바 업데이트
        updateUploadProgress(i, totalCount, item.name);
        
        // 크롭된 이미지 또는 원본 파일 가져오기
        let file;
        if (item.mediaType === 'image') {
          file = await createCroppedImage(item);
        } else {
          // 동영상은 원본 사용
          try {
            file = await getFileFromIndexedDB(item.id);
          } catch (e) {
            const response = await fetch(item.previewUrl);
            const blob = await response.blob();
            file = new File([blob], item.name, { type: item.type });
          }
        }
        
        let result;
        if (item.mediaType === 'image') {
          // 이미지 업로드: POST /v24.0/{ad_account_id}/adimages
          const formData = new FormData();
          formData.append('file', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/adimages?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '이미지 업로드 실패');
          }
          
          // 응답 형식: { "images": { "image_name": { "hash": "..." } } }
          const imageName = Object.keys(data.images || {})[0];
          const hash = data.images?.[imageName]?.hash;
          if (!hash) {
            throw new Error('이미지 해시를 받을 수 없습니다');
          }
          
          result = {
            id: item.id,
            type: 'image',
            hash: hash,
            video_id: null
          };
        } else {
          // 동영상 업로드: POST /v24.0/{ad_account_id}/advideos
          const formData = new FormData();
          formData.append('source', file, item.name);
          
          const response = await fetch(
            `https://graph.facebook.com/${apiVersion}/${adAccountId}/advideos?access_token=${encodeURIComponent(accessToken)}`,
            {
              method: 'POST',
              body: formData
            }
          );
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error.message || '동영상 업로드 실패');
          }
          
          // 응답 형식: { "video_id": "..." }
          const videoId = data.video_id || data.id;
          if (!videoId) {
            throw new Error('동영상 ID를 받을 수 없습니다');
          }
          
          result = {
            id: item.id,
            type: 'video',
            hash: null,
            video_id: videoId
          };
        }
        
        uploadedResults.push(result);
        
        // 마지막 항목 업로드 완료 시 프로그레스 바 100%
        if (i === mediaItems.length - 1) {
          updateUploadProgress(totalCount, totalCount, '완료');
        }
      } catch (error) {
        console.error(`미디어 ${item.id} 업로드 실패:`, error);
        errors.push({
          id: item.id,
          name: item.name,
          error: error.message
        });
      }
    }
    
    if (errors.length > 0) {
      throw new Error(`${errors.length}개 파일 업로드 실패:\n${errors.map(e => `- ${e.name}: ${e.error}`).join('\n')}`);
    }
    
    // STEP 3으로 이동
    const step1Data = JSON.parse(sessionStorage.getItem('admake_step1_state'));
    sessionStorage.setItem('admake_step2_results', JSON.stringify({
      accountId: accountId,
      results: uploadedResults,
      landingUrl: step1Data.landingUrl
    }));
    
    alert('업로드 완료! STEP 3으로 이동합니다.');
    // window.location.href = `/admake/create/ad?account_id=${encodeURIComponent(accountId)}`;
    
  } catch (error) {
    console.error('업로드 오류:', error);
    if (confirm(`업로드 실패: ${error.message}\n\n재시도하시겠습니까?`)) {
      uploadBtn.disabled = false;
    } else {
      loadingOverlay.classList.remove('active');
    }
  } finally {
    if (uploadBtn.disabled) {
      loadingOverlay.classList.remove('active');
    }
  }
}

// ✅ 비율 버튼 이벤트 등록
function setupRatioButtons() {
  document.querySelectorAll('.admake-ratio-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const ratioStr = btn.getAttribute('data-ratio');
      const ratio = eval(ratioStr); // "9/16" -> 0.5625, "4/5" -> 0.8, "1/1" -> 1
      console.log(`[DEBUG] 비율 버튼 클릭: ${ratioStr} (${ratio})`);
      changeAspectRatio(ratio);
    });
  });
}

// ✅ 초기화
document.addEventListener('DOMContentLoaded', async () => {
  initCanvas();
  
  // 비율 버튼 이벤트 등록
  setupRatioButtons();
  
  // Step 2 초기화 (데이터 복구 강화)
  await initStep2();
  
  // 데이터가 없으면 로드 시도
  if (mediaItems.length === 0) {
    await loadStep1Data();
  }
  
  // 초기 가이드라인 표시
  updateGuideLines();
  
  updateUploadButtonState(); // 초기 버튼 상태 설정
});
</script>

</body>
</html>
